# 要件管理DB PRD（Product Requirements Document）

## 1. プロダクト概要

### 1.1 目的

コーディングエージェントによる基幹業務システムの受託スクラッチ開発を支援するための要件管理システム。人間の関与を最小化しつつ、業務要件・システム要件の担保と、仕様変更に対する影響調査・要件記載の半自動化を実現する。

本ツールは新規スクラッチ開発を前提とする。既存システムからの移行（コードベースから要件を逆生成する等）は対象外とする。

### 1.2 解決する課題

| 課題             | 本システムでの解決策                                    |
| ---------------- | ------------------------------------------------- |
| 仕様の完全性問題 | 受入基準のGWT形式化＋AIによる曖昧性検出                  |
| コンテキスト維持問題 | 階層構造化された要件DB＋AIエージェント間の情報共有     |
| 変更伝播問題     | 依存関係の明示＋AIによる影響範囲自動検出                 |

### 1.3 基本思想

- 「不完全な仕様を前提とした設計」を採用
- 人間は業務観点・判断が必要な部分に集中
- 設計の詳細化・テスト生成・検証はAIに委任
- Critic Loop（受入基準→テスト→検証→修正）で品質を担保

### 1.4 コーディングエージェントの能力仮定と本ツールの役割

本ツールは、コーディングエージェント（Claude Code等）を「指示された範囲を高精度に実装するプログラマー」と位置づける。

コーディングエージェントができること：
- 明示された変更対象ファイルに対して、指示どおりの変更を高精度に実装する
- 指示に含まれる受入条件を満たすようにコードを修正する
- 指示された範囲内での整合性（型、API契約、テスト）を維持する

コーディングエージェントが自発的にはやらないこと：
- 指示範囲外への波及影響の検出と対処
- 変更対象として明示されていないファイルの修正
- 業務要件や設計意図を踏まえた「本来直すべき範囲」の判断

この「波及影響の見落とし」こそが、本ツールが解決すべき中核課題である。

### 1.5 コーディングエージェントへの依頼パターン

本ツールからコーディングエージェントへの依頼は、以下の2パターンに分かれる。

| パターン | 目的 | 入力 | 出力 | エージェントの役割 |
|---------|------|------|------|-------------------|
| 影響調査ジョブ | 変更要求に対する影響範囲の特定 | InvestigationRequest | InvestigationResult | コード依存関係の探索、影響ファイルの列挙、正本との突合 |
| 改修ジョブ | 確定した影響範囲に対する実装変更 | ModificationPackage | PR作成 | 指示範囲内の実装、テスト、PR作成（1.4の能力仮定に基づく） |

影響調査ジョブでは、エージェントはコード解析を能動的に行い、正本では捕捉できない依存関係を発見する。一方、改修ジョブでは、エージェントは与えられたスコープ（allow_paths）内でのみ作業し、スコープ外への波及は行わない。

---

## 2. 要件階層構造

### 2.1 全体構造

```
プロダクト要件（PR）
  ├─ ターゲットユーザー
  ├─ 体験目標
  ├─ 品質目標（横断の非機能を含む）
  ├─ デザインシステム（DS）
  ├─ UXガイドライン（UX）
  └─ 開発前提（Tech Stack / Coding Constraints）

業務領域（BD）
 └ 業務タスク（BT）
     └ 業務要件（BR）  ※1:N関係
          ↓ realizes（参照）
システム領域（SD）
 └ システム機能（SF）
      ├─ システム要件（SR）
      │    └─ 受入基準（AC）
      └─ 実装単位SD（N）  ※画面／API／バッチ／外部I/F 等
            └─ 実装（Code）  ※GitHub上の実体への参照
```

業務側（BD→BT→BR）とシステム側（SD→SF→SR/実装単位SD）は独立した階層構造を持ち、BRとSFは「realizes」リンクで参照関係を持つ。1つのBRが複数のSFを参照することも、1つのSFが複数のBRから参照されることもある。

### 2.2 各層の定義

| 層             | 問いかけ                        | 記述者    | 記述内容                                                                 |
| -------------- | ------------------------------- | --------- | ------------------------------------------------------------------------ |
| プロダクト要件 | 誰のために、どんな体験を        | PO/PdM    | ターゲット、体験目標、品質目標（横断NFR含む）、デザイン方針               |
| 業務領域       | どの業務をまとめるか            | 業務担当者 | 連続性のある業務タスクを括る集計単位                                     |
| 業務タスク     | いつ誰が何をして業務を進めるか  | 業務担当者 | 業務プロセス上の具体的タスク、前後関係、入出力                           |
| 業務要件       | なぜ必要か、何を達成したいか    | 業務担当者/BA | ビジネス上の目的・課題・制約、関係者の合意範囲                         |
| システム領域   | どの機能群をまとめるか          | SE/AI     | 関連するシステム機能を括る集計単位。ドメイン境界に対応                   |
| システム機能   | どの機能単位で仕様を束ねるか    | SE/AI     | 画面・API・バッチ等の機能の箱。SR（機能/非機能/データ/例外）と実装単位SDをひも付ける単位 |
| システム要件   | システムとして何を保証すべきか  | SE/AI     | 機能仕様、非機能、例外、データ要件（ユーザー視点の外形）                 |
| 受入基準       | 何をもってOKとするか            | QA/AI     | GWT形式、検証可能な条件（ブラックボックスで書く）                        |
| 実装単位SD     | どう実現するか                  | AI/SE     | 画面/API/バッチ/外部I/Fごとの設計。DB/API/画面/処理構造、設計決定        |
| 実装           | 実際のコード                    | AI        | GitHub上のファイル（.ts, .tsx等）。要件管理DBでは参照のみ                |

---

## 3. 要件記述仕様

本章では、要件管理DBに登録する各層の記述ルールを定義する。2章で示した階層構造（PR / BD→BT→BR / SD→SF→SR→AC→実装単位SD）に沿って、それぞれ「何を書くか」「なぜその粒度か」を説明する。

### 記述形式について

本章で定義する各項目は、以下の2つの形式で記述する。

| 形式 | 用途 | 特徴 |
|------|------|------|
| YAML | 構造化データ、リスト、手順 | AIが解析しやすく、UIでの構造化表示に適する |
| Markdown | 自由記述、説明文 | 見出し・箇条書き・強調が使え、可読性が高い |

各項目の記述形式は、項目定義の表に「形式」列で明記する。形式が指定されていない項目（IDや名前等）はプレーンテキストとして扱う。

---

### 3.1 プロダクト要件（PR）

プロダクト要件は、プロジェクト全体の前提を定義する正本である。「誰のために、どんな体験を、どんな技術で実現するか」をここに集約する。

下位の要件（BD/BT/BR/SD/SF/SR/AC/実装単位SD）をAIが生成するとき、また改修指示パッケージを作成するとき、このPRを常に参照する。PRに記載された品質目標やUXガイドライン、技術スタックが、すべての下位要件と実装の前提条件となる。

### なぜこの層を置くか

コーディングエージェントは、個別の要件だけを見て実装すると、プロジェクト全体の方針と矛盾した選択をしてしまうことがある。たとえば「UIライブラリはshadcn/uiを使う」という方針があるのに、個別の画面でMUIを使ってしまう、といった問題が起きる。

PRを正本として定義し、すべての要件生成・改修指示にPRを添付することで、プロジェクト全体の一貫性を担保する。

### 記述項目（必須）

| 項目 | 形式 | 説明 |
|------|:----:|------|
| pr_id | - | 一意識別子（例：PR-001） |
| target_users | Markdown | ターゲットユーザーの定義。ペルソナ、利用シーン、前提知識 |
| experience_goals | Markdown | 体験目標。ユーザーがこのシステムで得たい価値、感情、行動変容 |
| quality_goals | Markdown | 品質目標。横断的な非機能要件（性能、可用性、セキュリティ等） |
| design_system | Markdown | デザインシステム。カラー、タイポグラフィ、コンポーネント方針 |
| ux_guidelines | Markdown | UXガイドライン。操作性、フィードバック、エラー表示の方針 |
| tech_stack_profile | YAML | 開発前提。フレームワーク、言語、DB、認証等の技術選定（後述） |

### 記述項目（推奨）

| 項目 | 形式 | 説明 |
|------|:----:|------|
| coding_conventions | YAML | コーディング規約。命名規則、ディレクトリ構成、テスト方針など |
| forbidden_choices | YAML | 採用しない技術・方針。明示的に禁止するもの |

### tech_stack_profileの構造

技術スタックは、プロジェクトごとに指定する範囲が異なる。すべてを指定する必要はなく、未指定のフィールドは「コーディングエージェントに委任（agent_decides）」として扱う。エージェントはPRの品質目標・UXガイドラインと整合する選択を行う。

```typescript
interface TechStackProfile {
  // 未指定フィールドの扱い
  policy: {
    unspecified_fields: 'agent_decides';  // 常にこの値
  };

  frontend?: {
    framework?: 'Next.js' | 'Remix' | 'Nuxt' | 'Other';
    language?: 'TypeScript' | 'JavaScript' | 'Other';
    styling?: 'Tailwind' | 'CSS Modules' | 'styled-components' | 'Other';
    ui_library?: string;  // 例: "shadcn/ui", "MUI", "Chakra UI"
  };

  backend?: {
    runtime?: 'Node.js' | 'Deno' | 'Bun' | 'Other';
    framework?: 'Hono' | 'Express' | 'Fastify' | 'NestJS' | 'Other';
  };

  database?: {
    provider?: 'Supabase' | 'PostgreSQL' | 'MySQL' | 'MongoDB' | 'Other';
    orm?: 'Drizzle' | 'Prisma' | 'Kysely' | 'TypeORM' | 'None' | 'Other';
  };

  auth?: {
    provider?: 'BetterAuth' | 'NextAuth' | 'Supabase Auth' | 'Clerk' | 'Other';
  };

  hosting?: {
    frontend?: 'Vercel' | 'Cloudflare Pages' | 'Cloud Run' | 'Other';
    backend?: 'Cloud Run' | 'Supabase Edge Functions' | 'AWS Lambda' | 'Other';
  };

  constraints?: {
    must_use?: string[];      // 明示的に必須（例: ["Supabase Row Level Security"]）
    must_not_use?: string[];  // 明示的に禁止（例: ["jQuery", "Moment.js"]）
    notes?: string;           // 追加の制約（例: "モノレポで管理"、"pnpm必須"）
  };
}
```

### tech_stack_profileの記述例（YAML形式）

以下は、一部の技術だけを指定し、残りはエージェントに委任する例。

```yaml
tech_stack_profile:
  policy:
    unspecified_fields: agent_decides

  frontend:
    framework: Next.js
    language: TypeScript
    styling: Tailwind
    ui_library: shadcn/ui

  backend:
    runtime: Node.js
    framework: Hono

  database:
    provider: Supabase
    # orm は未指定 → エージェントが選択

  auth:
    provider: BetterAuth

  # hosting は未指定 → エージェントが選択

  constraints:
    must_use:
      - Supabase Row Level Security
      - Zod（バリデーション）
    must_not_use:
      - jQuery
      - Moment.js
    notes: |
      モノレポ（Turborepo）で管理。
      パッケージマネージャはpnpm。
```

### coding_conventionsの記述例（YAML形式）

```yaml
coding_conventions:
  naming:
    files: kebab-case        # 例: invoice-list.tsx
    components: PascalCase   # 例: InvoiceList
    functions: camelCase     # 例: calculateTax
    constants: SCREAMING_SNAKE_CASE  # 例: MAX_RETRY_COUNT

  directory_structure:
    pattern: feature-based   # features/, shared/, libs/ の構成
    notes: |
      - features/{feature-name}/components/
      - features/{feature-name}/hooks/
      - features/{feature-name}/api/
      - shared/components/
      - shared/hooks/
      - libs/{library-name}/

  testing:
    unit_test_pattern: "*.test.ts"
    e2e_test_pattern: "*.e2e.ts"
    coverage_target: 80%
    test_runner: vitest

  code_style:
    linter: biome
    formatter: biome
    max_line_length: 100
```

### PRの運用

PRはプロジェクト作成時に初期設定し、以降は大きな方針変更がない限り変更しない。変更する場合は、影響を受ける下位要件（特に実装単位SD）を確認し、必要に応じて改修要求（CR）として扱う。

---

### 3.2 業務領域（BD）

業務領域は、関連する業務タスクをまとめるフォルダのような存在である。「請求」「在庫管理」「財務会計」といった業務の大分類に対応し、影響調査の初期スコープを絞る際の単位として機能する。

| 項目 | 必須 | 形式 | 説明 |
|------|:----:|:----:|------|
| bd_id | ○ | - | 一意識別子（例：BD-BIL） |
| name | ○ | - | 業務領域名（例：請求） |
| description | ○ | Markdown | この領域が扱う業務範囲と、隣接領域との境界 |

業務領域自体に詳細な記述は不要。配下の業務タスク（BT）を適切にグルーピングできていればよい。

---

### 3.3 業務タスク（BT）

業務タスクは「いつ、誰が、何をするか」を記述する単位である。システム機能ではなく、業務プロセス上の作業を表現する。

たとえば「請求書発行」は業務タスクだが、「請求書PDF生成API」はシステム機能であり、ここには書かない。この区別が重要なのは、業務タスクを起点にすることで「なぜこの機能が必要か」というトレーサビリティが生まれるからである。

### 記述項目

| 項目 | 必須 | 形式 | 説明 |
|------|:----:|:----:|------|
| task_id | ○ | - | 一意識別子（例：BT-BIL-001） |
| name | ○ | - | タスク名（例：請求書発行） |
| description | ○ | Markdown | タスクの目的、開始条件、終了条件、成果物 |
| business_context | ○ | Markdown | 実施組織・ロール、タイミング・頻度、前後の業務、根拠となる業務ルール |
| process_steps | - | YAML | タスク内の流れを「いつ／誰が／何をする」で記述 |
| inputs | - | YAML | タスク開始時に必要な情報・伝票・イベント |
| outputs | - | YAML | タスク完了後に残す成果物・状態変化・通知 |
| concept_ids | - | YAML | 関連する概念辞書のID（配列） |

### process_stepsの書き方（YAML形式）

業務の流れを時系列で書く。システムの内部処理ではなく、業務担当者の視点で何が起きるかを記述する。

```yaml
process_steps:
  - when: 締め日翌営業日
    who: 経理担当
    action: 計上対象の受注を抽出する
  - when: 抽出後
    who: 経理担当
    action: 計上結果を確認し、例外を差し戻す
  - when: 確認後
    who: システム
    action: 計上完了を関係者に通知する
```

### inputs / outputs の書き方（YAML形式）

```yaml
inputs:
  - name: 確定済み受注データ
    source: 受注管理システム
    condition: ステータスが「確定」
  - name: 与信判定結果
    source: 与信管理システム

outputs:
  - name: 売上伝票
    destination: 会計システム
  - name: 計上完了通知
    destination: 営業担当（メール）
```

---

### 3.4 業務要件（BR）

業務要件は、業務タスクを達成するために「守りたいこと」を言語化したものである。具体的な画面やAPIの話ではなく、業務上の目的・制約・ルールを記述する。

「請求書をPDFで出力できる」は業務要件として適切だが、「PDFはReact-PDFで生成する」は実装の話であり、ここには書かない。

### 記述項目

| 項目 | 必須 | 形式 | 説明 |
|------|:----:|:----:|------|
| br_id | ○ | - | 一意識別子（例：BR-BIL-001） |
| task_id | ○ | - | 親となる業務タスクのID |
| goal | ○ | Markdown | 達成したい業務成果と、その測り方 |
| constraints | ○ | YAML | 守るべき業務ルール、制度、例外の扱い（配列） |
| owner | ○ | - | この要件の決定権を持つ人 |
| concept_ids | - | YAML | 関連する概念辞書のID（配列、1件以上推奨） |
| impacts | - | YAML | 影響するシステム領域（配列、1件以上推奨） |

### goalとconstraintsの違い

goalは「何を達成したいか」をMarkdownで自由に記述する。constraintsは「何を守らなければならないか」をYAML配列で列挙する。

```yaml
goal: |
  受注確定後、翌営業日までに売上として計上し、
  月次決算に反映できる状態にする。

constraints:
  - 計上日は出荷日基準とする（出荷していない受注は計上しない）
  - 与信NGの取引先への売上は、与信部門の承認後に計上する
  - 計上後の取消は、取消伝票を起票して対応する（直接削除は禁止）

concept_ids:
  - REVENUE_RECOGNITION
  - CREDIT_CHECK

impacts:
  - SD-FI
  - SD-BIL
```

---

### 3.5 システム領域（SD）

システム領域は、関連するシステム機能をまとめる単位である。業務領域（BD）が業務タスク（BT）をまとめるのと対称の構造になっている。

ドメイン駆動設計でいう境界づけられたコンテキストに近い概念で、「請求ドメイン」「財務会計ドメイン」といった単位を想定している。影響調査で「この変更は請求ドメインに閉じるか、財務会計ドメインにも波及するか」を判断する際の基準となる。

| 項目 | 必須 | 形式 | 説明 |
|------|:----:|:----:|------|
| sd_id | ○ | - | 一意識別子（例：SD-BIL） |
| name | ○ | - | システム領域名（例：請求） |
| description | ○ | Markdown | この領域が扱う責務範囲と、隣接領域との境界 |

---

### 3.6 システム機能（SF）

システム機能は、ユーザーから見える機能の単位である。「請求書発行機能」「売上計上機能」のように、業務タスクとの対応関係が読み取れる粒度で切る。

1つのシステム機能の内部には、画面・API・バッチ・外部I/Fといった複数の実装形態が含まれることがある。たとえば「請求書発行機能」は、発行画面＋発行API＋帳票生成バッチ＋外部送信I/Fで構成されるかもしれない。これらの実装形態ごとの設計は、後述する実装単位SD（3.9）で記述する。

### なぜこの層を置くか

システム要件（SR）や非機能要件を「どの機能に対して課すか」を明確にするためである。「請求書発行は5秒以内に完了すること」という非機能要件は、個別のAPIやバッチではなく、機能全体に対して課される。この「機能全体」を表現する箱がシステム機能である。

### 記述項目

| 項目 | 必須 | 形式 | 説明 |
|------|:----:|:----:|------|
| sf_id | ○ | - | 一意識別子（例：SF-BIL-010） |
| sd_id | ○ | - | 親となるシステム領域のID |
| name | ○ | - | 機能名（例：請求書発行機能） |
| description | ○ | Markdown | 誰に対して何を提供するか、構成要素、入出力、責務範囲 |
| design_policy | - | Markdown | 複数の実装単位SDにまたがる横断的な設計方針 |

### 業務要件（BR）との関係

システム機能は業務要件を「実現する」関係（realizes）にある。1つのBRが複数のSFで実現されることも、1つのSFが複数のBRから参照されることもある。この多対多の関係は、realizesリンクとして明示的に管理する。リンクの種類と管理方法の詳細は4.3「要件間リンク」を参照。

---

### 3.7 システム要件（SR）

システム要件は、システム機能に対して「何を保証すべきか」を記述する。ユーザー視点の外形的な仕様であり、内部実装の詳細は書かない。

### 記述項目

| 項目 | 必須 | 形式 | 説明 |
|------|:----:|:----:|------|
| sr_id | ○ | - | 一意識別子（例：SR-BIL-001） |
| sf_id | ○ | - | 親となるシステム機能のID |
| description | ○ | Markdown | 要件の内容 |
| type | ○ | - | 観点種別（後述） |
| priority | ○ | - | 優先度 |
| concept_ids | - | YAML | 関連する概念辞書のID（配列） |

### typeによる観点の分類

システム要件は、以下の4つの観点に分類する。この分類は、後続の受入基準（AC）を適切なパターンで書くために使う。

| type | 観点 | 記述する内容 |
|------|------|-------------|
| functional | 機能 | この機能で何ができるか |
| data | データ | 入出力や保持すべきデータの意味・整合性・粒度 |
| exception | 例外 | 失敗・差し戻し・保留・再試行など例外時の振る舞い |
| non-functional | 非機能 | 性能、可用性、操作性、監査性、セキュリティなど |

### 非機能要件の書き方（Markdown）

非機能要件は、ユーザー視点で測定可能な形で書く。内部処理の性能予算配分は実装単位SDの責務である。

```markdown
<!-- 悪い例（測定できない） -->
請求書発行は高速に処理されること

<!-- 良い例（測定可能） -->
請求書発行指示からPDFダウンロード可能になるまで5秒以内（P95）。

**前提条件：**
- 同時発行指示10件以下
- 1請求書あたり明細100行以下

**前提を超える場合：**
処理中表示を出し、完了時にメール通知する。
```

---

### 3.8 受入基準（AC）

受入基準は、システム要件に対して「OK/NGを判定できる」検証可能な条件を記述する。Given-When-Then（GWT）形式のYAML構造を採用する。

### 基本構造（YAML形式）

受入基準は全体をYAMLで記述する。これにより、AIによる解析、テスト生成、検証の自動化が容易になる。

```yaml
ac_id: AC-001
sr_id: SR-001
scenario: "売上計上が正しく行われる"

given:
  description: "受注が確定している"
  preconditions:
    - "受注ステータスが「確定」"
    - "請求先が与信OK"
  test_data:
    order_id: "ORD-2025-001"
    amount: 100000
    tax_rate: 0.10

when:
  description: "売上計上処理を実行する"
  trigger: "日次バッチ実行"

then:
  description: "売上が正しく計上される"
  expected_outcomes:
    - "売上計上結果を売上照会で確認できる"
    - "売上金額 = 受注金額"
    - "消費税額 = 受注金額 × 税率（端数切捨て）"
  verification_steps:
    - "売上照会で order_id を検索し、計上金額と税額を確認する"

dependencies:
  - sr_id: SR-010
    description: "与信チェック機能が有効"
```

### 必須フィールド

| フィールド | 説明 |
|-----------|------|
| ac_id, sr_id, scenario | 識別情報 |
| given.description, given.preconditions | 前提条件（1件以上） |
| when.description, when.trigger | 実行契機 |
| then.description, then.expected_outcomes | 期待結果（1件以上） |

### カバレッジ要件

各SRに対して、以下を満たすACを用意する：

- 正常系：最低1つ（必須）
- 異常系：最低1つ（必須）
- 境界条件：該当する場合

### 禁止事項

ACは検証可能でなければならない。以下は禁止：

- 「適切に処理される」「正しく動作する」等の曖昧表現
- 検証手段が存在しない条件
- 実装詳細への言及（テーブル名、クラス名、SQL等）

### type別のGWTテンプレート

SRのtypeに応じて、ACの典型パターンが異なる。要件整形AIがACを自動生成する際は、以下のテンプレートを参照する。

#### functional（機能要件）の場合

```yaml
given:
  description: "[前提となる状態・データ]"
  preconditions:
    - "[ユーザーの状態（ログイン済み、権限あり等）]"
    - "[対象データの状態（存在する、特定のステータス等）]"
when:
  description: "[ユーザーの操作・システムのトリガー]"
  trigger: "[ボタン押下、API呼び出し、バッチ起動等]"
then:
  description: "[期待される結果]"
  expected_outcomes:
    - "[状態の変化]"
    - "[出力されるデータ・画面・通知]"
```

#### non-functional（非機能要件）の場合

```yaml
given:
  description: "[負荷条件・環境条件]"
  preconditions:
    - "[同時接続数、データ量、ピーク時間帯]"
    - "[外部システムの可用性前提]"
when:
  description: "[測定対象の操作]"
  trigger: "[測定開始点となる操作]"
then:
  description: "[性能指標]"
  expected_outcomes:
    - "[応答時間（P95/P99、最大値）]"
    - "[スループット、可用性（SLO）]"
```

#### exception（例外要件）の場合

```yaml
given:
  description: "[異常条件・エラー状態]"
  preconditions:
    - "[入力不備、権限不足、外部I/F不通、二重実行等]"
when:
  description: "[異常条件下での操作]"
  trigger: "[通常操作と同じトリガー]"
then:
  description: "[エラーハンドリングの結果]"
  expected_outcomes:
    - "[ユーザーへのエラー表示・メッセージ]"
    - "[データの整合性（ロールバック、補償）]"
    - "[ログ・監査証跡、再実行可否]"
```

#### data（データ要件）の場合

```yaml
given:
  description: "[入力データの条件]"
  preconditions:
    - "[データの形式、制約、境界値]"
    - "[関連データの存在・整合性前提]"
when:
  description: "[データ処理・変換]"
  trigger: "[登録、更新、計算、集計等]"
then:
  description: "[出力データの検証]"
  expected_outcomes:
    - "[出力データの形式・値]"
    - "[整合制約（一意性、参照整合性）]"
    - "[計算結果（端数処理、丸め）]"
```

---

### 3.9 実装単位SD

実装単位SDは、システム機能（SF）を構成する個々の実装形態（画面/API/バッチ/外部I/F）に対する設計を記述する。SFが「何を提供するか」を定義するのに対し、実装単位SDは「どう実現するか」を定義する。

### 記述項目（必須）

| 項目 | 必須 | 形式 | 説明 |
|------|:----:|:----:|------|
| impl_unit_id | ○ | - | 一意識別子（例：IU-BIL-010-01） |
| sf_id | ○ | - | 親となるシステム機能のID |
| type | ○ | - | 実装形態（screen / api / batch / external_if） |
| name | ○ | - | 実装単位名（例：請求書PDF生成バッチ） |
| description | ○ | Markdown | この実装単位が担う責務、入出力の概要 |
| entry_point | ○ | - | エントリポイントファイルパス |

### entry_pointの重要性

entry_pointは、コーディングエージェントが実装ファイルを特定する起点となる。影響調査では、このパスから依存関係を辿って影響範囲を検出する。

entry_pointには「機能を主体的に表現するファイル」を登録する。共通ユーティリティ（src/utils/等）は登録しない。共通処理への影響は、影響調査時のコード依存分析で検出する。

```yaml
# 良い例：機能のエントリポイント
entry_point: src/features/billing/pages/InvoiceIssuePage.tsx
entry_point: src/features/billing/api/issueInvoice.ts
entry_point: jobs/invoice-pdf-batch.ts

# 登録しない例：共通処理
# src/utils/taxCalculation.ts
# src/libs/pdfGenerator.ts
```

### 記述項目（任意）

設計の詳細度は、機能の複雑性に応じてユーザーが制御する。以下の項目を必要に応じて追加する。すべてYAML形式で記述する。

| 項目 | 形式 | 用途 |
|------|:----:|------|
| api_definition | YAML | エンドポイント、入出力、エラー、冪等性、認可境界 |
| data_model | YAML | エンティティと関係、主キー、制約、状態遷移 |
| core_logic | YAML | 計算式、判定条件、状態遷移、締め処理等の業務ルール |
| db_design | YAML | トランザクション境界、整合性方針、排他、履歴管理 |
| screen_design | YAML | 画面目的、導線、入力項目、バリデーション、状態表示 |
| exception_handling | YAML | 失敗モードごとの対処、再実行可否、運用介入点 |
| detailed_spec | YAML | 上記を詳細設計レベルまで具体化（項目定義、シーケンス等） |

### 任意項目の記述例

```yaml
api_definition:
  endpoint: POST /api/billing/invoices/{invoiceId}/issue
  description: 請求書を発行し、PDFを生成する
  input:
    - name: invoiceId
      type: string
      required: true
      description: 請求書ID
    - name: options
      type: object
      required: false
      properties:
        sendEmail:
          type: boolean
          default: false
  output:
    success:
      type: object
      properties:
        pdfUrl: string
        issuedAt: datetime
    error:
      - code: INVOICE_NOT_FOUND
        httpStatus: 404
      - code: ALREADY_ISSUED
        httpStatus: 409
  idempotency: invoiceIdに対して冪等（2回目以降は既存PDFを返す）
  authorization: billing:invoice:issue 権限が必要

data_model:
  entities:
    - name: Invoice
      description: 請求書
      attributes:
        - name: id
          type: string
          primaryKey: true
        - name: status
          type: enum
          values: [draft, issued, canceled]
        - name: issuedAt
          type: datetime
          nullable: true
  state_transitions:
    Invoice:
      draft: [issued]
      issued: [canceled]
      canceled: []

core_logic:
  tax_calculation:
    description: 消費税計算
    formula: "税額 = 税抜金額 × 税率"
    rounding: 切り捨て
    precision: 1円単位
  issue_validation:
    preconditions:
      - 請求書ステータスがdraft
      - 明細が1件以上存在
      - 請求先が与信OK
```

### 統制レベルの目安

どこまで詳細に書くかは、機能の特性によって変える。

| レベル | 記述する項目 | 適用場面 |
|--------|-------------|---------|
| 最小 | api_definition, data_model, core_logic | 単純な機能、AIに実装裁量を与えたい場合 |
| 標準 | 上記 + db_design, screen_design, exception_handling | 一般的な業務機能 |
| 厳格 | 上記 + detailed_spec | 複雑な締め処理、外部I/F多数、監査要件が強い領域 |

設計で確定した判断は、可能な限り「設計決定ログ」に残す。後続の影響調査で「なぜそうなっているか」を再現するためである。

---

### 3.10 実装（Code）

実装は、GitHub上に保存される実際のコードファイル（.ts、.tsx、.sql等）を指す。要件管理DBでは管理対象とせず、実装単位SDのentry_pointを通じて参照する。

コードの変更履歴・差分管理はGitHub（PR、コミット）に委ねる。要件管理DBは、改修指示パッケージを通じてコーディングエージェントに指示を出し、結果としてGitHub上に生成されるPRをトレーサビリティの終点とする。

---

### 3.11 概念辞書（Concept）

概念辞書は、システム内の重要な用語を定義し、同義語や関連するシステム領域を整理した辞書である。全体をYAML形式で記述する。

たとえば「請求書」という用語は、文脈によって「Invoice」「Bill」「Statement」と呼ばれることがある。これらを概念辞書で関連付けることで、AIが変更要求を分析する際の誤解を減らせる。

### 運用方針

概念辞書は最初から完璧に作る必要はない。要件入力や変更要求の分析のたびに、AIが概念候補を抽出し、人間が承認・修正・却下することで、徐々に育てていく。

MVPでは参考情報として位置づけ、影響調査AIが補助的に参照する。概念辞書の充実度に応じて影響調査の精度が向上する設計とするが、必須とはしない。

### 概念辞書の育成フロー

概念辞書は以下のフローで育成する。

```
1. 概念候補の抽出
   AIがBT/BR/SR登録時に本文から用語を抽出
   ↓
2. マッチング
   既存の概念辞書と照合
   - 一致 → 既存概念へのリンクを提案
   - 不一致 → 新規概念候補として提案
   ↓
3. 人間の判断
   - 承認 → 概念辞書に登録、要件にリンク
   - 却下 → 今後この語句では提案しない
   - 保留 → 「未処理」タブに表示、後で判断
   ↓
4. 育成
   概念辞書が充実 → 影響調査の精度向上
```

UIでの提案タイミング：

| タイミング | 動作 |
|-----------|------|
| 新規登録時 | 保存前にリアルタイムで提案 |
| 編集時 | 変更差分に対して提案 |
| AI生成時 | 草案と同時に概念候補を抽出・提案 |

### 記述項目

| 項目 | 必須 | 説明 |
|------|:----:|------|
| concept_id | ○ | 一意識別子（例：TAX_INVOICE_JP） |
| name | ○ | 概念名（正式名称） |
| synonyms | - | 同義語・別名（配列、1件以上推奨） |
| system_domains | ○ | 影響するシステム領域（配列、1件以上） |
| definition | ○ | 定義（Markdown形式で記述可） |
| must_read | - | 必読ドキュメントのパス（配列） |

### 記述例（YAML形式）

```yaml
TAX_INVOICE_JP:
  name: 適格請求書
  synonyms:
    - インボイス
    - 登録番号
    - 税率ごとの対価
  system_domains:
    - SD-BIL
    - SD-FI
  definition: |
    消費税法に基づく適格請求書（インボイス）。
    登録番号、税率ごとの対価、消費税額を記載する。
    2023年10月以降、仕入税額控除の要件となる。

    ## 必須記載事項
    - 適格請求書発行事業者の氏名または名称
    - 登録番号
    - 取引年月日
    - 取引内容（軽減税率対象品目である旨）
    - 税率ごとに区分した対価の額および適用税率
    - 税率ごとに区分した消費税額等
    - 書類の交付を受ける事業者の氏名または名称
  must_read:
    - system/SD-BIL/SF-BIL-010.md
    - system/SD-FI/SF-FI-020.md
```

synonymsが空だと、自然言語での検索やマッチングが効きにくい。業務用語とシステム用語の両方を登録することを推奨する。

---

## 4. 変更管理と影響調査

本章では、運用フェーズで変更要求が発生したとき、正本をどう更新し、影響範囲をどう特定し、改修に繋げるかを定義する。3章が「要件の書き方」を定めるのに対し、本章は「要件の変え方」を定める。

---

### 4.1 変更管理の全体像

#### なぜ変更管理が重要か

コーディングエージェントは「指示された範囲を高精度に実装する」能力を持つが、「指示範囲外への波及影響」は自発的に検出しない（1.4参照）。この特性により、変更要求に対して「どこまで影響するか」を人間とAIが協力して特定し、適切なスコープでエージェントに指示を出す仕組みが必要になる。

本章で定義する変更管理は、以下の3つの要素で構成される。

| 要素 | 役割 | 管理対象 |
|------|------|---------|
| 変更要求（CR） | 変更の起点を記録し、ライフサイクルを追跡する | 変更の内容、影響範囲、ステータス |
| 要件間リンク | 要件同士の関係を明示し、影響の波及経路を可視化する | realizes、depends_on等のリンク |
| 影響調査 | 変更要求に対する影響範囲を特定する | 正本ベースのトップダウン分析、コードベースのボトムアップ分析 |

#### 変更対応の流れ

変更要求から改修完了までの流れを概観する。

```
┌─────────────────────────────────────────────────────────────────────┐
│                         変更対応フロー                              │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  ① CR起票                                                          │
│     │  変更要求を記録し、初期スコープを指定                         │
│     ▼                                                              │
│  ② 影響調査                                                        │
│     │  トップダウン分析（正本）＋ボトムアップ分析（コード）          │
│     ▼                                                              │
│  ③ 疑義リンクの解消                                                │
│     │  矛盾・不整合があれば、人間がレビューして解消                  │
│     ▼                                                              │
│  ④ 改修指示パッケージ生成                                          │
│     │  影響範囲を確定し、コーディングエージェントへの指示を生成      │
│     ▼                                                              │
│  ⑤ 改修実行・検証・マージ                                          │
│        コーディングエージェントが実装、人間がPRをレビュー           │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

以降、各要素の詳細を説明する。

---

### 4.2 変更要求（CR）

変更要求（Change Request）は、正本に対する変更の起点を記録する。機能追加、仕様変更、バグ修正など、正本の更新を伴うすべての変更はCRとして起票する。

#### なぜCRを起票するか

CRを起票せずに直接正本を編集すると、以下の問題が発生する。

- 影響調査が行われず、波及影響を見落とす
- 変更履歴が追跡できず、「いつ、なぜ変わったか」が分からなくなる
- 複数人での作業で競合・重複が発生する

CRを起点にすることで、変更の意図と影響範囲を明示し、レビュー可能な形で変更を進められる。

#### 記述項目

| 項目 | 必須 | 形式 | 説明 |
|------|:----:|:----:|------|
| cr_id | ○ | - | 一意識別子（例：CR-2025-001） |
| title | ○ | - | 変更要求の件名 |
| description | ○ | Markdown | 変更の背景、目的、期待される結果 |
| requester | ○ | - | 起票者（人名またはシステム） |
| affected_scope | ○ | YAML | 変更対象として想定する要件ID群（初期スコープ） |
| status | ○ | - | ステータス（後述） |
| priority | - | - | 優先度（high / medium / low） |
| due_date | - | - | 期限 |
| investigation_id | - | - | 紐づく影響調査のID（調査実行後に設定） |

#### affected_scopeの書き方

変更対象として「触る可能性がある」要件IDを列挙する。正確である必要はなく、影響調査の起点として使う。

```yaml
affected_scope:
  business_requirements:
    - BR-BIL-001
  system_requirements:
    - SR-BIL-001
    - SR-BIL-002
  system_functions:
    - SF-BIL-010
  notes: |
    請求書のPDF出力形式を変更するため、
    PDF生成処理に関連する要件が影響を受ける想定。
```

#### ステータス遷移

CRは以下のステータスを持ち、一方向に遷移する。

```
draft → investigating → reviewed → approved → completed
                                      ↓
                                   rejected
```

| ステータス | 意味 | 次のアクション |
|-----------|------|---------------|
| draft | 起票済み、影響調査前 | 影響調査を開始する |
| investigating | 影響調査中 | 調査結果を確認する |
| reviewed | 調査完了、疑義解消済み | 改修を承認するか判断する |
| approved | 改修承認済み | 改修指示パッケージを生成する |
| completed | 改修完了 | （終了状態） |
| rejected | 却下 | （終了状態） |

---

### 4.3 要件間リンク

要件間リンクは、要件同士の関係を明示的に管理する仕組みである。2章で示した階層構造（BD→BT→BR→SF→SR→AC→実装単位SD）は親子関係だが、それとは別に、要件間には「実現する」「依存する」「矛盾する」といった関係がある。

#### なぜリンクを管理するか

リンクを明示的に管理することで、以下が可能になる。

- 影響調査でリンクを辿り、波及範囲を特定する
- 変更時に「この要件を変えると、どこに影響するか」を可視化する
- 矛盾する要件を事前に検出する

リンクが管理されていないと、影響調査はコード解析のみに頼ることになり、正本レベルでの影響把握ができない。

#### リンクの種類（relation_type）

本ツールで管理するリンクの種類を定義する。MVPでは以下の4種類を扱う。

| relation_type | 意味 | 方向 | 例 |
|---------------|------|------|-----|
| realizes | 業務要件をシステム機能が実現する | BR → SF | BR-BIL-001（請求書出力）→ SF-BIL-010（請求書発行機能） |
| depends_on | 前提として依存する | 任意 → 任意 | SR-BIL-002 → SR-FI-001（与信チェック結果に依存） |
| derives_from | 派生・詳細化する | 詳細 → 元 | 実装単位SD → SF |
| conflicts_with | 矛盾する可能性がある | 双方向 | SR-A ↔ SR-B（排他的な仕様） |

realizesリンクは、3章で説明したBRとSFの関係を明示するもの。depends_onは、ある要件が別の要件を前提とする場合に使う。conflicts_withは稀だが、排他的な仕様（Aを採用するとBは採用できない）を明示するために使う。

#### リンクの記述項目

| 項目 | 必須 | 説明 |
|------|:----:|------|
| link_id | ○ | リンクの一意識別子 |
| source_id | ○ | 参照元の要件ID |
| source_type | ○ | 参照元の種別（br / sf / sr / impl_unit 等） |
| target_id | ○ | 参照先の要件ID |
| target_type | ○ | 参照先の種別 |
| relation_type | ○ | リンクの種類（realizes / depends_on / derives_from / conflicts_with） |
| evidence | ○ | リンクの根拠（どのフィールドが関連するか、なぜリンクしたか） |
| last_confirmed | ○ | 最終確認日時 |
| suspect | ○ | 疑義フラグ（後述） |

#### 疑義管理（suspect状態）

要件間リンクは、時間の経過とともに「本当に正しいか分からない」状態になることがある。たとえば、SRを変更したとき、そのSRに依存するACの前提が崩れているかもしれない。

この「正しさに疑義がある状態」を管理するために、リンクにsuspect状態を持たせる。

| フィールド | 説明 |
|-----------|------|
| suspect | 疑義があるか（true = レビュー待ち）。trueの間は「信頼しない」扱い |
| suspect_severity | 疑義の重大度（high / medium / low） |
| suspect_reason | なぜ疑義になったかの短い根拠 |
| evidence_refs | 疑義の根拠（調査レポートID、コミットハッシュ等） |

suspect_severityの判定基準：

| 重大度 | 条件 | 例 |
|--------|------|-----|
| high | 誤りがあると要件の誤実装や設計判断ミスに直結 | SRの変更によりACの前提が崩れる |
| medium | 誤りがあると手戻りが増える | 実装単位SDの変更で関連SRの整合確認が必要 |
| low | 改善余地・情報不足のレベル | 概念辞書の同義語追加 |

疑義リンクは、影響調査の結果として自動検出されることもあれば、人間が手動でフラグを立てることもある。いずれの場合も、「確認して維持」または「修正」によって解消する。

#### 疑義リンク受信箱

suspect=trueのリンクを一覧表示し、処理するためのUIを提供する。

| 操作 | 動作 |
|------|------|
| 確認して維持 | suspect=false、last_confirmed=現在時刻に更新 |
| 修正 | リンク定義または参照元を編集し、整合を取った後にsuspect=false |

運用ルール：
- CR承認前にhigh/mediumを原則ゼロにする
- lowは警告に留め、作業を止めない
- 30日以上放置された疑義リンクはヘルススコアに反映する

---

### 4.4 影響調査の仕組み

影響調査は、変更要求に対して「どの要件・どのコードが影響を受けるか」を特定するプロセスである。本ツールでは、トップダウン分析（正本ベース）とボトムアップ分析（コードベース）を組み合わせた双方向アプローチを採用する。

#### なぜ双方向か

正本だけを見ても、コードだけを見ても、影響範囲は完全には分からない。

| 分析方法 | 強み | 弱み |
|---------|------|------|
| トップダウン（正本） | 業務要件レベルでの影響が分かる | 正本のリンクが不完全だと漏れる |
| ボトムアップ（コード） | 実際の依存関係を正確に把握できる | コード解析だけでは業務影響が分からない |

両方を組み合わせることで、正本の不完全さをコード解析で補い、コード解析だけでは見えない業務影響を正本から特定する。

#### トップダウン分析

変更要求を起点に、正本のリンクを辿って影響候補を特定する。

```
変更要求（CR）
  ↓ affected_scopeで指定された要件
業務要件（BR）
  ↓ realizesリンク
システム機能（SF）
  ↓ 親子関係
システム要件（SR）
  ↓ depends_onリンク
受入基準（AC）
  ↓ 親子関係
実装単位SD
  ↓ entry_point
影響候補ファイル群
```

トップダウン分析は、アプリ内のAI（5章で定義するimpact_analysis Tool）が正本を参照して実行する。

#### ボトムアップ分析

トップダウンで特定したentry_pointを起点に、コード依存関係を解析して影響範囲を展開する。その後、検出されたファイルから逆方向に正本を辿り、「正本には登録されていないが影響がある」範囲を特定する。

```
entry_point（トップダウンで特定）
  ↓ コード依存関係を解析
影響ファイル群
  ↓ entry_pointと突合
実装単位SD（正本に登録済みなら）
  ↓ 正本を逆引き
システム要件
  ↓ 正本を逆引き
業務要件
  ↓
「この業務要件も影響範囲に含めますか？」と提案
```

ボトムアップ分析は、コーディングエージェント（6章で定義するInvestigationRequest/Result）がコード解析を行い、その結果をアプリに返却する。

#### 逆流提案の例

変更要求「売上伝票の消費税仕訳の仕様変更」の場合：

1. トップダウンで SR-SD-010（売上消費税仕訳）→ /app/sd/tax-journal/ を特定
2. コード解析で TaxJournalService.ts が共通処理であり、仕入伝票からも呼ばれていることを検出
3. ボトムアップで /app/mm/tax-journal/ → SR-MM-008（仕入消費税仕訳）→ BR-MM-001（仕入計上）を逆引き
4. AIが提案：「消費税仕訳の共通処理を変更すると、仕入伝票計上にも影響します。BR-MM-001も影響範囲に含めますか？」

この逆流が機能するには、エントリポイント → 実装単位SD → システム機能 → システム要件 → 業務要件 の逆引きが可能である必要がある。本ツールは新規スクラッチ開発を前提としているため、開発開始時点からentry_pointを登録していけば、この条件は自然に満たされる。

#### 影響範囲の確定

影響調査の結果、影響範囲候補（allow_paths候補）が得られる。候補が多すぎる場合（デフォルト50ファイル超）は、影響範囲レビューAI（5章で定義するimpact_review Tool）が絞り込みを提案する。

最終的なallow_pathsは、以下の要素を総合して確定する。

| 要素 | 内容 |
|------|------|
| トップダウン結果 | 正本から特定された影響候補 |
| ボトムアップ結果 | コード解析から特定された影響ファイル |
| レビューAIの提案 | 絞り込み提案、残存リスク |
| 人間の判断 | レビューAIが判断を委ねた項目への回答 |

---

### 4.5 変更対応フロー

4.1で示した流れに沿って、各ステップの詳細を説明する。

#### ① CR起票

| 操作者 | 操作内容 |
|--------|---------|
| ユーザー | 変更要求を作成し、affected_scopeで初期スコープを指定 |
| システム | CRレコードを作成、status=draftに設定 |

#### ② 影響調査

| 操作者 | 操作内容 |
|--------|---------|
| ユーザー | CR画面から「影響調査」を開始 |
| システム | トップダウン分析を実行し、影響候補を生成 |
| システム | InvestigationRequestを生成し、コーディングエージェントに調査ジョブを投入 |
| システム | status=investigatingに更新 |
| エージェント | コード依存関係を解析し、InvestigationResultを返却 |
| システム | 結果を取り込み、トップダウン結果と突合 |
| システム | 矛盾・不足があれば、該当リンクにsuspect=trueを設定 |

影響範囲候補が閾値を超えた場合：

| 操作者 | 操作内容 |
|--------|---------|
| システム | 影響範囲レビューAIを起動 |
| レビューAI | 絞り込み提案、残存リスク、人間への確認事項を返却 |
| ユーザー | 確認事項に回答 |
| システム | recommended_allow_pathsを採用、residual_risksを記録 |

#### ③ 疑義リンクの解消

| 操作者 | 操作内容 |
|--------|---------|
| ユーザー | 疑義リンク受信箱でhigh/mediumを優先して処理 |
| ユーザー | 「確認して維持」または「修正」を選択 |
| システム | suspect=false、last_confirmedを更新 |
| システム | high/mediumが閾値以下になったらstatus=reviewedに更新 |

#### ④ 改修指示パッケージ生成

| 操作者 | 操作内容 |
|--------|---------|
| ユーザー | 影響調査結果を確認し、改修を承認 |
| システム | status=approvedに更新 |
| ユーザー | 「改修指示パッケージ生成」を実行 |
| システム | ModificationPackageを生成（6.8参照） |

パッケージに含まれる内容：

| 項目 | 内容 |
|------|------|
| allow_paths | 変更を許可するファイルパス |
| 参照要件ID群 | BT/BR/SF/SR/AC/実装単位SD |
| investigation_id | 影響調査の根拠 |
| residual_risks | 残存リスク（PRレビュー時の参考） |

#### ⑤ 改修実行・検証・マージ

| 操作者 | 操作内容 |
|--------|---------|
| システム | コーディングエージェントに改修ジョブを投入 |
| エージェント | allow_paths内で実装、テスト、PR作成 |
| ユーザー | PRをレビューし、マージ |
| システム | status=completedに更新 |

#### フロー図

```
┌────────────────────────────────────────────────────────────────────────┐
│ ① CR起票                                                               │
│    ユーザーが変更要求を作成、affected_scopeを指定                       │
│    status: draft                                                       │
└────────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌────────────────────────────────────────────────────────────────────────┐
│ ② 影響調査                                                             │
│    ┌─────────────────────┐     ┌─────────────────────┐                │
│    │ トップダウン分析     │────▶│ ボトムアップ分析     │                │
│    │ （正本ベース）       │     │ （コードベース）     │                │
│    └─────────────────────┘     └─────────────────────┘                │
│                  │                         │                          │
│                  └────────────┬────────────┘                          │
│                               ▼                                       │
│                    ┌─────────────────────┐                            │
│                    │ 結果の突合           │                            │
│                    │ ・allow_paths候補生成│                            │
│                    │ ・疑義リンク検出     │                            │
│                    └─────────────────────┘                            │
│                               │                                       │
│              ┌────────────────┴────────────────┐                      │
│              ▼                                 ▼                      │
│    ┌─────────────────────┐        ┌─────────────────────┐            │
│    │ 50ファイル以下      │        │ 50ファイル超        │            │
│    │ → そのまま採用      │        │ → 影響範囲レビューAI│            │
│    └─────────────────────┘        └─────────────────────┘            │
│    status: investigating                                              │
└────────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌────────────────────────────────────────────────────────────────────────┐
│ ③ 疑義リンクの解消                                                     │
│    ユーザーがhigh/mediumの疑義リンクを処理                              │
│    「確認して維持」または「修正」                                       │
│    status: reviewed（high/mediumが閾値以下になったら）                  │
└────────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌────────────────────────────────────────────────────────────────────────┐
│ ④ 改修指示パッケージ生成                                               │
│    ユーザーが改修を承認、パッケージを生成                               │
│    status: approved                                                    │
└────────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌────────────────────────────────────────────────────────────────────────┐
│ ⑤ 改修実行・検証・マージ                                               │
│    コーディングエージェントが実装、ユーザーがPRレビュー                 │
│    status: completed                                                   │
└────────────────────────────────────────────────────────────────────────┘
```

---

### 4.6 変更要求の例

具体的なCRの記述例を示す。

#### 例1：機能追加

```yaml
cr_id: CR-2025-001
title: 請求書のメール送付機能追加
description: |
  請求書発行後に、PDFをメールで顧客に自動送付する機能を追加する。

  ## 背景
  現状は請求書PDFを手動でダウンロードし、メールに添付して送付している。
  この作業を自動化することで、経理担当者の負荷を軽減する。

  ## 期待される結果
  - 請求書発行画面から「メール送付」を選択できる
  - 送付履歴が残り、再送付もできる

requester: 田中（経理部）
status: draft
priority: high

affected_scope:
  business_tasks:
    - BT-BIL-001
  business_requirements:
    - BR-BIL-001
  system_functions:
    - SF-BIL-010
  notes: |
    請求書発行機能の拡張として実装する想定。
    メール送信基盤は既存のものを流用できるか要確認。
```

#### 例2：仕様変更

```yaml
cr_id: CR-2025-002
title: 消費税端数処理の変更（切捨て→四捨五入）
description: |
  消費税計算の端数処理を、現行の「切捨て」から「四捨五入」に変更する。

  ## 背景
  取引先からの要望により、端数処理方法を変更する。

  ## 影響範囲（想定）
  - 請求書出力
  - 売上計上
  - 仕入計上（同一の税計算ロジックを使用している場合）

requester: システム管理者
status: draft
priority: medium

affected_scope:
  system_requirements:
    - SR-BIL-001
    - SR-FI-001
  acceptance_criteria:
    - AC-BIL-001-01
  notes: |
    税計算ロジックが共通処理化されている場合、
    売上・仕入の両方に影響する可能性がある。
    影響調査で確認する。
```

---

## 5. AIエージェント構成

本章では、要件管理DBアプリに組み込むAIエージェントの設計を定義する。コーディングエージェント（Claude Code等）への連携は6章で扱い、本章ではアプリ内で動作する「登録支援」「影響調査」「品質チェック」等のAI機能を対象とする。

### 5章と6章の責務境界

本PRDでは、AI機能を2つの層に分けて設計している。

| 層 | 章 | 技術 | 責務 |
|----|:---:|------|------|
| アプリ内AI | 5章 | Mastra Agent | 登録支援（草案生成）、品質チェック、トップダウン影響分析、InvestigationRequest生成 |
| コーディングエージェント | 6章 | Claude Agent SDK | コード解析、ボトムアップ影響分析、改修実行、PR作成 |

影響調査における連携の流れ：

```
┌─────────────────────────────────────────────────────────────────────┐
│ 5章: アプリ内AI（Mastra Agent）                                      │
│                                                                     │
│  impact_analysis Tool                                               │
│    1. 正本のリンクを辿ってトップダウン分析                            │
│    2. 影響候補のentry_pointを特定                                    │
│    3. InvestigationRequestを生成                                    │
│                        │                                            │
└────────────────────────┼────────────────────────────────────────────┘
                         │ ジョブ投入
                         ▼
┌─────────────────────────────────────────────────────────────────────┐
│ 6章: コーディングエージェント（Claude Agent SDK）                    │
│                                                                     │
│  InvestigationRequest を受け取り:                                   │
│    1. entry_pointからコード依存関係を解析                            │
│    2. 影響ファイルを特定（ボトムアップ分析）                          │
│    3. InvestigationResultを返却                                     │
│                        │                                            │
└────────────────────────┼────────────────────────────────────────────┘
                         │ 結果返却
                         ▼
┌─────────────────────────────────────────────────────────────────────┐
│ 5章: アプリ内AI（結果の突合）                                        │
│                                                                     │
│    1. トップダウン結果とボトムアップ結果を突合                        │
│    2. 矛盾・不足があれば疑義リンクを生成                              │
│    3. allow_paths候補を生成                                         │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

この分離により、アプリ内AIは「正本ベースの分析」に集中し、コーディングエージェントは「コードベースの分析と実装」に集中できる。

---

### 5.1 設計思想

### 単一Agent・複数Tool構成

従来は機能ごとに独立したAIエージェント（要件整形AI、影響調査AI、Critic AI等）を想定していたが、以下の理由から「単一のAgent + 機能別Tool群」の構成を採用する。

| 観点 | 独立Agent構成 | 単一Agent + Tool群 |
|------|--------------|-------------------|
| コードベース | エージェントごとに分散 | 1つのAgentコードで集中管理 |
| コンテキスト共有 | エージェント間で受け渡し必要 | セッション内で自然に維持 |
| 機能の組み合わせ | 別々に呼び出し | 同一チャット内で連続実行可能 |
| PR参照 | 各エージェントで個別実装 | Agent起動時に1回注入 |

この設計により、ユーザーは1つのチャットUIから「BT登録 → BR登録 → SF/SR/AC生成 → 影響調査」といった一連の作業を、文脈を維持したまま進められる。

### 登録方式の併存

要件管理DBアプリは、すべてのデータに対して2つの登録方式を提供する。

| 方式 | 用途 | UI |
|------|------|-----|
| マニュアル登録 | 内容が明確、手打ちしたい場合 | 従来のフォーム画面 |
| チャット登録 | 曖昧な入力を整形したい、文章で指示したい場合 | AIチャットUI |

チャット登録はマニュアル登録を代替するものではなく、ユーザーの好みや状況に応じて選べる補助手段である。どちらの方式でも、最終的に登録されるデータの形式は同じ。

---

### 5.2 アーキテクチャ

### 技術選定

AIエージェント基盤としてMastraを採用する。Mastraは以下の機能を提供し、本設計の要件を満たす。

| Mastra機能 | 本設計での用途 |
|-----------|---------------|
| Agent | 統合AIエージェントの実装 |
| Tools | 機能別Tool（登録支援、影響調査等）の定義 |
| Workflow | 複数Toolの連携フロー定義 |
| Memory | チャットセッション内のコンテキスト維持 |
| Structured Output | DB登録用のYAML/JSON生成 |

### 全体構成

```
┌─────────────────────────────────────────────────────────────────┐
│ 要件管理DBアプリ（Next.js）                                       │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  ┌─────────────┐    ┌─────────────┐                            │
│  │ マニュアル    │    │ AIチャット   │                            │
│  │ 登録画面     │    │ UI          │                            │
│  └──────┬──────┘    └──────┬──────┘                            │
│         │                  │                                    │
│         │                  ▼                                    │
│         │         ┌───────────────────────────────────┐        │
│         │         │ 統合Agent（Mastra）                │        │
│         │         │                                   │        │
│         │         │  ┌─────────────────────────────┐  │        │
│         │         │  │ Tool群                      │  │        │
│         │         │  │ ・bt_draft（BT草案生成）     │  │        │
│         │         │  │ ・br_draft（BR草案生成）     │  │        │
│         │         │  │ ・system_draft（SF/SR/AC）  │  │        │
│         │         │  │ ・impl_unit_draft（実装単位SD）│ │        │
│         │         │  │ ・impact_analysis（影響調査）│  │        │
│         │         │  │ ・impact_review（範囲レビュー）│ │        │
│         │         │  │ ・critic_check（品質チェック）│ │        │
│         │         │  │ ・concept_extract（概念抽出）│  │        │
│         │         │  │ ・db_design（DB設計支援）   │  │        │
│         │         │  │ ・test_generate（テスト生成）│  │        │
│         │         │  └─────────────────────────────┘  │        │
│         │         │                                   │        │
│         │         │  ┌─────────────────────────────┐  │        │
│         │         │  │ Context Provider             │  │        │
│         │         │  │ ・PR（tech_stack_profile等）  │  │        │
│         │         │  │ ・現在の階層位置              │  │        │
│         │         │  │ ・既存要件・概念辞書          │  │        │
│         │         │  └─────────────────────────────┘  │        │
│         │         └───────────────────────────────────┘        │
│         │                  │                                    │
│         ▼                  ▼                                    │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │ 正本API（Supabase）                                      │   │
│  │ ・草案の一時保存（draft状態）                             │   │
│  │ ・確定後の正本登録                                       │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### Agent定義

```typescript
import { Agent } from '@mastra/core';

export const requirementsAgent = new Agent({
  name: 'requirements-agent',
  instructions: `
    あなたは要件管理DBの登録支援AIです。
    ユーザーの自然言語入力を、構造化された要件（BT/BR/SF/SR/AC/実装単位SD）に整形します。
    
    ## 行動原則
    - 草案を生成するが、勝手にDBに保存しない（ユーザーの確定操作を待つ）
    - 曖昧な入力は明確化のための質問をする
    - 生成した草案の根拠と未確定事項を明示する
    - PRのtech_stack_profileとcoding_conventionsに従う
    
    ## コンテキスト
    起動時に以下が注入されます：
    - プロダクト要件（PR）
    - 現在の階層位置（BD/BT/BR/SD/SF等）
    - 関連する既存要件
    - 概念辞書
  `,
  model: {
    provider: 'anthropic',
    name: 'claude-sonnet-4-20250514',
  },
  tools: [
    btDraftTool,
    brDraftTool,
    systemDraftTool,
    implUnitDraftTool,
    impactAnalysisTool,
    impactReviewTool,
    criticCheckTool,
    conceptExtractTool,
    dbDesignTool,
    testGenerateTool,
    saveToDraftTool,
    commitDraftTool,
  ],
});
```

---

### 5.3 Tool一覧

統合Agentが使用するToolを定義する。各Toolは特定の機能を担い、旧設計のエージェント（要件整形AI、影響調査AI等）を包含する。

### 登録支援Tool群

| Tool名 | 旧設計での対応 | 入力 | 出力 | 責務 |
|--------|--------------|------|------|------|
| bt_draft | 要件整形AI | 自然文、BD ID | BT草案 | 業務タスクの草案生成 |
| br_draft | 要件整形AI | 自然文、BT ID | BR草案 | 業務要件の草案生成 |
| system_draft | 要件整形AI | BR ID群、自然文 | SF/SR/AC草案 | システム側要件の一括草案生成 |
| impl_unit_draft | 要件整形AI | SF ID、自然文 | 実装単位SD草案 | 実装設計の草案生成 |
| concept_extract | 要件整形AI（部分） | テキスト | 概念候補リスト | テキストから概念を抽出 |

### 分析・検証Tool群

| Tool名 | 旧設計での対応 | 入力 | 出力 | 責務 |
|--------|--------------|------|------|------|
| impact_analysis | 影響調査AI | CR ID、変更内容 | 影響範囲候補、InvestigationRequest | 変更影響の分析、コーディングエージェントへのジョブ生成 |
| impact_review | 影響範囲レビューAI | allow_paths候補 | 絞り込み提案、残存リスク | N:N爆発時の影響範囲レビュー |
| critic_check | Critic AI | BT/BR/SF/SR/AC | 指摘リスト、修正案 | 曖昧さ・矛盾・漏れの検出 |
| db_design | DB設計AI | SR/AC、既存データモデル | 論理データモデル案、制約案 | データ設計の補完・検証 |
| test_generate | テスト生成AI | AC、テスト方針 | テストケース、テストデータ案 | ACからテストを自動生成 |

### 共通Tool群

| Tool名 | 入力 | 出力 | 責務 |
|--------|------|------|------|
| get_context | なし | PR、現在位置、既存要件 | コンテキスト情報の取得 |
| save_to_draft | 草案データ | draft ID | 草案の一時保存（未確定状態） |
| commit_draft | draft ID | 正本ID | 草案の正本登録（確定） |
| search_requirements | 検索クエリ | 要件リスト | 既存要件の検索 |
| get_links | 要件ID | リンクリスト | 要件間リンクの取得 |

---

### 5.4 Tool定義詳細

### bt_draft（BT草案生成）

```typescript
const btDraftTool = createTool({
  id: 'bt_draft',
  description: '業務タスク（BT）の草案を生成する',
  inputSchema: z.object({
    naturalLanguageInput: z.string().describe('業務の説明（自然文）'),
    bdId: z.string().describe('親となる業務領域ID'),
    generateBR: z.boolean().optional().describe('BRも同時に生成するか'),
  }),
  execute: async ({ naturalLanguageInput, bdId, generateBR }, { context }) => {
    // 1. コンテキスト取得
    const pr = await context.getProductRequirement();
    const existingBTs = await context.getBTsByBD(bdId);
    const concepts = await context.getConceptDictionary();
    
    // 2. LLMで草案生成
    const btDraft = await generateWithLLM({
      template: 'bt_draft',
      input: naturalLanguageInput,
      context: { pr, existingBTs, concepts },
    });
    
    // 3. 概念候補を抽出
    const conceptCandidates = await extractConcepts(btDraft, concepts);
    
    // 4. BRも生成する場合
    let brDrafts = [];
    if (generateBR) {
      brDrafts = await generateWithLLM({
        template: 'br_draft_from_bt',
        input: btDraft,
        context: { pr },
      });
    }
    
    // 5. 未確定事項を抽出
    const uncertainties = extractUncertainties(btDraft, brDrafts);
    
    return {
      btDraft,
      brDrafts,
      conceptCandidates,
      uncertainties,
      previewAvailable: true,
    };
  },
});
```

### system_draft（SF/SR/AC一括生成）

```typescript
const systemDraftTool = createTool({
  id: 'system_draft',
  description: 'BR群からSF/SR/ACを一括生成する',
  inputSchema: z.object({
    brIds: z.array(z.string()).describe('対象BR IDのリスト'),
    additionalContext: z.string().optional().describe('追加の指示や制約'),
  }),
  execute: async ({ brIds, additionalContext }, { context }) => {
    // 1. コンテキスト取得
    const pr = await context.getProductRequirement();
    const brs = await context.getBRsByIds(brIds);
    const existingSFs = await context.getRelatedSFs(brIds);
    
    // 2. PRのtech_stack_profileを参照して生成
    const systemDrafts = await generateWithLLM({
      template: 'system_draft',
      input: { brs, additionalContext },
      context: {
        pr,
        existingSFs,
        techStack: pr.tech_stack_profile,
        codingConventions: pr.coding_conventions,
      },
    });
    
    // 3. ACはSRのtypeに応じたGWTテンプレートを使用
    for (const sf of systemDrafts.sfs) {
      for (const sr of sf.srs) {
        sr.acs = await generateACsByType(sr, pr);
      }
    }
    
    // 4. 実装単位SDのentry_pointはcoding_conventionsに従う
    for (const sf of systemDrafts.sfs) {
      sf.implUnits = await generateImplUnitPaths(sf, pr.coding_conventions);
    }
    
    // 5. realizesリンクを生成
    const realizesLinks = generateRealizesLinks(brs, systemDrafts.sfs);
    
    return {
      sfDrafts: systemDrafts.sfs,
      realizesLinks,
      uncertainties: systemDrafts.uncertainties,
      previewAvailable: true,
    };
  },
});
```

### impact_analysis（影響調査）

```typescript
const impactAnalysisTool = createTool({
  id: 'impact_analysis',
  description: '変更要求に対する影響範囲を分析する',
  inputSchema: z.object({
    crId: z.string().describe('変更要求ID'),
    changeDescription: z.string().describe('変更内容の説明'),
    targetIds: z.array(z.string()).optional().describe('明示的な対象要件ID'),
  }),
  execute: async ({ crId, changeDescription, targetIds }, { context }) => {
    // 1. トップダウン分析（正本ベース）
    const topDownResult = await analyzeTopDown({
      crId,
      changeDescription,
      targetIds,
      requirements: await context.getRequirements(),
      links: await context.getLinks(),
    });
    
    // 2. コーディングエージェント向けInvestigationRequest生成
    const investigationRequest = buildInvestigationRequest({
      crId,
      entryPoints: topDownResult.affectedEntryPoints,
      changeContext: {
        summary: changeDescription,
        affected_concepts: topDownResult.relatedConcepts,
        expected_change_types: topDownResult.expectedChangeTypes,
      },
      requirementsContext: {
        product_requirement: await context.getProductRequirement(),
        business_requirements: topDownResult.affectedBRs,
        system_requirements: topDownResult.affectedSRs,
        acceptance_criteria: topDownResult.affectedACs,
      },
    });
    
    // 3. 疑義候補を抽出
    const suspectCandidates = detectSuspectLinks(topDownResult);
    
    return {
      topDownResult,
      investigationRequest,
      suspectCandidates,
      nextStep: 'コーディングエージェントに調査ジョブを投入してください',
    };
  },
});
```

### critic_check（品質チェック）

```typescript
const criticCheckTool = createTool({
  id: 'critic_check',
  description: '要件の曖昧さ・矛盾・漏れを検出する',
  inputSchema: z.object({
    targetIds: z.array(z.string()).describe('チェック対象の要件ID'),
    checkLevel: z.enum(['quick', 'standard', 'thorough']).optional(),
  }),
  execute: async ({ targetIds, checkLevel = 'standard' }, { context }) => {
    const targets = await context.getRequirementsByIds(targetIds);
    const pr = await context.getProductRequirement();
    
    // 検証ルールを適用
    const issues = [];
    
    // 1. 曖昧性チェック
    for (const target of targets) {
      const ambiguities = checkAmbiguity(target);
      issues.push(...ambiguities);
    }
    
    // 2. 検証可能性チェック（AC向け）
    for (const ac of targets.filter(t => t.type === 'ac')) {
      const verifiability = checkVerifiability(ac);
      issues.push(...verifiability);
    }
    
    // 3. 整合性チェック（リンク間）
    const links = await context.getLinksByTargets(targetIds);
    const inconsistencies = checkConsistency(targets, links);
    issues.push(...inconsistencies);
    
    // 4. PRとの整合性チェック
    const prMismatches = checkPRAlignment(targets, pr);
    issues.push(...prMismatches);
    
    // 5. 致命度でソート
    issues.sort((a, b) => severityOrder[b.severity] - severityOrder[a.severity]);
    
    // 6. 修正案を生成
    const suggestions = await generateSuggestions(issues, targets);
    
    return {
      issues,
      suggestions,
      summary: {
        critical: issues.filter(i => i.severity === 'critical').length,
        warning: issues.filter(i => i.severity === 'warning').length,
        info: issues.filter(i => i.severity === 'info').length,
      },
    };
  },
});
```

---

### 5.5 コンテキスト注入

チャットセッション開始時に、以下のコンテキストをAgentに自動注入する。これにより、ユーザーは毎回「Next.jsで開発している」「請求領域の話をしている」等の前提を説明する必要がない。

### 注入されるコンテキスト

| コンテキスト | 内容 | 用途 |
|-------------|------|------|
| product_requirement | PR全体（tech_stack_profile、coding_conventions含む） | 技術選定、命名規則の遵守 |
| current_location | 現在のUI位置（例：BD-BIL > BT-BIL-001） | 親子関係の自動設定 |
| related_requirements | 現在位置に関連する既存要件 | 重複回避、参照提案 |
| concept_dictionary | 概念辞書（プロジェクト全体） | 用語の統一、概念リンク |
| recent_drafts | 同一セッションで生成した未確定草案 | 連続作業の文脈維持 |

### 注入のタイミング

```typescript
// チャットUI起動時
async function initializeChatSession(location: UILocation): Promise<ChatSession> {
  const context = await buildContext(location);
  
  const session = await requirementsAgent.createSession({
    initialContext: {
      product_requirement: context.pr,
      current_location: {
        type: location.type,  // 'bd' | 'bt' | 'br' | 'sd' | 'sf' | 'sr' | 'cr'
        id: location.id,
        breadcrumb: location.breadcrumb,
      },
      related_requirements: context.relatedRequirements,
      concept_dictionary: context.concepts,
    },
    systemMessage: buildSystemMessage(location),
  });
  
  return session;
}

// 位置に応じたシステムメッセージ
function buildSystemMessage(location: UILocation): string {
  switch (location.type) {
    case 'bd':
      return `業務領域「${location.name}」に業務タスクを追加します。どのような業務を登録しますか？`;
    case 'bt':
      return `業務タスク「${location.name}」に業務要件を追加します。この業務で達成したいことは何ですか？`;
    case 'cr':
      return `変更要求「${location.name}」の影響調査を行います。変更内容を教えてください。`;
    // ...
  }
}
```

---

### 5.6 チャットUIの設計

### 画面構成

```
┌─────────────────────────────────────────────────────────────────┐
│ AIアシスタント - BD-BIL（請求）                          [×]    │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │ クイックアクション                                      │   │
│  │ [BT登録] [BR登録] [SF/SR/AC生成] [影響調査] [品質チェック] │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │ チャット履歴                                            │   │
│  │                                                         │   │
│  │ System: BD-BIL（請求）に業務タスクを追加します。         │   │
│  │         どのような業務を登録しますか？                   │   │
│  │                                                         │   │
│  │ User: 請求書を発行してメールで送る業務                   │   │
│  │                                                         │   │
│  │ Agent: BT草案を生成しました。                           │   │
│  │        ┌─────────────────────────────────┐              │   │
│  │        │ 📋 草案プレビュー               │              │   │
│  │        │ BT-BIL-002: 請求書発行・送付    │              │   │
│  │        │ [詳細を見る]                    │              │   │
│  │        └─────────────────────────────────┘              │   │
│  │        [確定] [編集] [BRも生成]                          │   │
│  │                                                         │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │ [メッセージを入力...]                           [送信]  │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### クイックアクション

クイックアクションは、よく使う操作をワンクリックで実行するためのショートカット。押下すると、対応するToolが呼び出され、必要に応じてAgentが追加質問を行う。

| アクション | 呼び出されるTool | 動作 |
|-----------|-----------------|------|
| BT登録 | bt_draft | 「業務の説明を入力してください」とプロンプト |
| BR登録 | br_draft | 「達成したい業務要件を説明してください」とプロンプト |
| SF/SR/AC生成 | system_draft | 現在のBRからシステム側要件を一括生成 |
| 影響調査 | impact_analysis | 現在のCRに対して影響分析を開始 |
| 品質チェック | critic_check | 現在表示中の要件をチェック |

### 草案プレビュー

Agentが生成した草案は、チャット内に埋め込まれたプレビューカードとして表示する。プレビューカードから以下の操作が可能。

| 操作 | 動作 |
|------|------|
| 詳細を見る | 草案の全フィールドをモーダルで表示 |
| 確定 | commit_draft Toolを呼び出し、正本に登録 |
| 編集 | マニュアル登録画面を草案データで開く |
| やり直し | 草案を破棄し、再生成を依頼 |

### 草案の状態管理

草案は以下の状態を持つ。

```
draft（未確定）→ committed（確定済み）
       ↓
   discarded（破棄）
```

同一セッション内で生成された草案は、セッションが閉じられるまで保持される。セッション終了時に未確定の草案がある場合、ユーザーに確認を求める。

---

### 5.7 草案確定フロー

### 単一草案の確定

```
User: 請求書発行の業務を登録して

Agent: [bt_draft Tool呼び出し]
       BT草案を生成しました。
       
       [草案プレビュー: BT-BIL-002]
       
       [確定] [編集] [BRも生成]

User: [確定]をクリック

Agent: [commit_draft Tool呼び出し]
       BT-BIL-002を正本に登録しました。
       
       続けてBRを追加しますか？
       [BRを追加] [終了]
```

### 一括生成の確定

```
User: この業務に対してSF/SR/ACを作って

Agent: [system_draft Tool呼び出し]
       SF/SR/ACの草案を生成しました。
       
       [草案プレビュー]
       ├─ SF-BIL-020: 請求書送付機能
       │   ├─ SR-BIL-020: 請求書をメールで送付できる
       │   │   ├─ AC-BIL-020-01: 正常系
       │   │   └─ AC-BIL-020-02: 異常系
       │   └─ 実装単位SD:
       │       ├─ IU-BIL-020-01: 送付画面
       │       └─ IU-BIL-020-02: 送付API
       └─ realizesリンク: BR-BIL-002 → SF-BIL-020
       
       [全て確定] [個別に確認] [やり直し]

User: [個別に確認]をクリック

Agent: では順番に確認していきます。
       
       まずSF-BIL-020について：
       [草案詳細: SF-BIL-020]
       
       [確定] [編集] [スキップ]
```

### 確定前の品質チェック

一括確定時は、自動でcritic_checkを実行し、問題があれば警告を表示する。

```
User: [全て確定]をクリック

Agent: [critic_check Tool呼び出し]
       確定前にチェックを実行しました。
       
       ⚠️ 1件の警告があります：
       - AC-BIL-020-02の「エラー時」の定義が曖昧です
         → 「メール送信失敗時」に修正することを推奨
       
       [警告を無視して確定] [修正してから確定]
```

---

### 5.8 設計決定ログ

Agentが行った推論や補完は「設計決定ログ」として保存する。これにより、後から「なぜこの設計になったか」を追跡できる。

### ログ構造

```typescript
interface DesignDecisionLog {
  decision_id: string;
  created_at: string;
  created_by: 'agent' | 'human';
  
  // 何についての決定か
  context: {
    target_type: 'bt' | 'br' | 'sf' | 'sr' | 'ac' | 'impl_unit';
    target_id: string;
    field?: string;  // 特定フィールドについての決定の場合
  };
  
  // 決定内容
  decision: string;
  
  // 根拠
  rationale: {
    type: 'pr_reference' | 'ac_reference' | 'convention' | 'inference' | 'user_input';
    reference?: string;  // 参照元のID等
    explanation: string;
  };
  
  // 状態
  status: 'proposed' | 'confirmed' | 'rejected';
  confirmed_by?: string;
  confirmed_at?: string;
}
```

### ログの生成タイミング

| シーン | ログ生成 |
|--------|---------|
| 草案生成時 | Agentが推論で補完した箇所にproposed状態でログを付与 |
| 確定時 | proposed状態のログをconfirmedに更新 |
| 編集時 | 人間が変更した箇所にhumanソースでログを追加 |

### 例

```yaml
decision_id: DEC-2025-001
created_at: "2025-01-25T10:30:00Z"
created_by: agent

context:
  target_type: impl_unit
  target_id: IU-BIL-020-02
  field: entry_point

decision: "エントリポイントを /api/billing/invoices/[id]/send.ts に設定"

rationale:
  type: pr_reference
  reference: PR-001.coding_conventions.directory_structure
  explanation: |
    PRのcoding_conventionsでfeature-based構造が指定されているため、
    /api/billing/ 配下にAPIを配置。
    動的ルーティングには[id]を使用（Next.js App Router規約）。

status: confirmed
confirmed_by: user-123
confirmed_at: "2025-01-25T10:35:00Z"
```

---

### 5.9 エラーハンドリング

### Tool実行失敗時

```
User: SF/SR/ACを生成して

Agent: [system_draft Tool呼び出し]
       
       ⚠️ 生成中にエラーが発生しました。
       
       原因：対象のBRが見つかりません。
       現在の位置（BT-BIL-001）に関連するBRを先に登録してください。
       
       [BRを登録] [別のBTを選択]
```

### 曖昧な入力時

```
User: 請求関連の機能を追加して

Agent: 「請求関連の機能」をもう少し具体的に教えてください。
       
       例えば：
       - 請求書を発行する
       - 請求書を顧客にメールで送る
       - 入金を消し込む
       - 請求残高を確認する
       
       どのような業務を追加しますか？
```

### コンテキスト不足時

```
User: これのテストを作って

Agent: どの要件のテストを生成しますか？
       
       現在表示中の要件：
       - SR-BIL-001: 請求書PDFに登録番号を出力
       - SR-BIL-002: 請求書をメールで送付
       
       [SR-BIL-001] [SR-BIL-002] [両方]
```

---

### 5.10 UXと少人数開発への効果

本設計が目指すUXと少人数開発への効果を整理する。

### UXへの効果

| 効果 | 実現方法 |
|------|---------|
| 迷いの除去 | コンテキスト自動注入により、前提説明が不要 |
| やり直しの削減 | critic_checkによる事前検証、草案状態での編集 |
| 結果の見える化 | 草案プレビュー、設計決定ログ |
| 柔軟な作業フロー | 自然言語でもクイックアクションでも同じことができる |

### 少人数開発への効果

| 効果 | 実現方法 |
|------|---------|
| 専門家不足の補完 | PRに従った一貫性のある生成、品質チェックの自動化 |
| 手戻りの局所化 | 草案段階での検証、影響調査の標準化 |
| 自動検証の標準化 | critic_check、test_generateによる品質の下限確保 |
| 属人性の排除 | 設計決定ログによる判断根拠の可視化 |

### 共通原則

すべてのToolに共通する行動原則：

| 原則 | 理由 |
|------|------|
| 勝手に確定しない | 誤登録防止、人間の検証機会確保 |
| 根拠と未確定を分けて提示する | 判断の透明性、編集箇所の明確化 |
| PRに従う | プロジェクト全体の一貫性確保 |
| 曖昧な入力は明確化を促す | 品質の下限確保、手戻り防止 |

---

## 6. コーディングエージェント連携設計

本章では、要件管理DBアプリが保持するコンテキスト（PR→BT→BR→SF→SR→AC→実装単位SD）を活用し、コーディングエージェントによる自動改修を安全かつ再現可能に実行するための連携設計を定義する。

### 6.1 目的とスコープ

要件管理DBアプリ側は「影響調査ジョブの投入」「改修指示パッケージの生成」「実行ジョブの管理」「進捗と結果の可視化」を担い、コーディングエージェント側は「影響調査」「改修」「テスト」「PR作成」を担う。

| 対象                       | 役割                                                         |
| -------------------------- | ------------------------------------------------------------ |
| 要件管理DBアプリ           | InvestigationRequest/ModificationPackage生成、チャットUI/タスクUI、結果受信、履歴保管 |
| ジョブAPI / タスク管理     | タスク作成（冪等）、状態/イベント永続化、イベント配信（SSE/WebSocket） |
| コーディングエージェント Worker | 影響調査、改修実行、テスト、PR作成（サンドボックス内でジョブ単位に起動） |

### 6.2 アーキテクチャ方針

実行制御と表示（リアルタイム進捗）を分離し、ジョブの状態とイベントは必ず永続化する。

- 実行はジョブ（task\_id）単位で管理し、状態とイベントは永続ストアを正とする
- Workerは「少なくとも一回」起動されうる前提で冪等に動く
- クライアントは切断/再接続しても、イベントを復元できる

想定する分離構成（例）：

```
┌──────────────────────────────────────────────┐
│ 要件管理DBアプリ（UI）                         │
│ - 要件閲覧/編集                                │
│ - チャットUI / タスクUI                        │
└───────────────────────┬──────────────────────┘
                        │ HTTPS
                        ▼
┌──────────────────────────────────────────────┐
│ ジョブAPI / タスク管理                         │
│ - タスク作成（冪等）                            │
│ - 状態/イベント永続化                           │
│ - イベント配信（SSE/WebSocket）                 │
└───────────────────────┬──────────────────────┘
                        │ 起動トリガ（キュー等）
                        ▼
┌──────────────────────────────────────────────┐
│ コーディングエージェント Worker（エフェメラル）   │
│ - Agent SDK + オーケストレーション               │
│ - サンドボックス化されたワークスペース            │
└──────────────────────────────────────────────┘
```

### 6.3 コーディングエージェント基盤の選択

本番運用（ジョブ制御、権限制御、サンドボックス、Hooks等）を前提に、プログラマティックに制御可能なSDK型の基盤を採用する。

- CLI型の完成品は、ターミナル対話のUXには優れるが、アプリ組み込みとジョブ管理には不向き
- SDK型は、ジョブ制御・検証・権限・ログの統合がしやすい

### 6.4 ジョブ種別

コーディングエージェントへの依頼は、以下の2種類のジョブに分かれる。

| ジョブ種別 | 目的 | 入力 | 出力 | スコープ制約 |
|-----------|------|------|------|-------------|
| 影響調査ジョブ | 変更要求に対する影響範囲の特定 | InvestigationRequest | InvestigationResult | 探索のみ（コード変更なし） |
| 改修ジョブ | 確定した影響範囲に対する実装変更 | ModificationPackage | PR作成 | allow\_pathsで制限 |

### 6.5 影響調査ジョブの入出力定義

#### InvestigationRequest（アプリ → エージェント）

```typescript
interface InvestigationRequest {
  // 識別子
  investigation_id: string;
  cr_id: string;
  project_id: string;
  repository_url: string;
  base_branch: string;

  // 探索起点（トップダウンで特定したentry_point群）
  entry_points: {
    impl_unit_id: string;
    sf_id: string;
    entry_point: string;           // ファイルパス
    investigation_hint?: string;   // 「この機能のどこを見るべきか」のヒント
  }[];

  // 探索制約
  exploration: {
    max_depth: number;             // 依存グラフの探索深さ上限（推奨: 5）
    include_patterns: string[];    // 探索対象パターン（例: ["src/**/*.ts", "src/**/*.tsx"]）
    exclude_patterns: string[];    // 除外パターン（例: ["node_modules/**", "**/*.test.ts"]）
    follow_dynamic_imports: boolean; // 動的importも追跡するか
  };

  // 変更要求の文脈（エージェントが影響判断に使う）
  change_context: {
    summary: string;               // 変更要求の概要
    affected_concepts: string[];   // 関連する概念辞書ID（任意）
    expected_change_types: ('logic' | 'data' | 'api' | 'ui' | 'config')[];
  };

  // 参照可能な正本（MCP経由でも取得可能だが、主要なものは同梱）
  requirements_context: {
    product_requirement: ProductRequirement;  // PR（tech_stack_profile含む）
    business_requirements: {
      br_id: string;
      goal: string;
      constraints: string[];
    }[];
    system_requirements: {
      sr_id: string;
      sf_id: string;
      description: string;
      type: 'functional' | 'non-functional' | 'exception' | 'data';
    }[];
    acceptance_criteria: {
      ac_id: string;
      sr_id: string;
      scenario: string;
      given: string;
      when: string;
      then: string;
    }[];
  };

  // 出力設定
  output: {
    include_file_snippets: boolean;  // 影響箇所のコードスニペットを含めるか
    max_files_per_category: number;  // カテゴリごとの最大ファイル数（爆発防止）
    confidence_threshold: number;    // この閾値未満のconfidenceは除外（0.0-1.0）
  };
}
```

#### InvestigationResult（エージェント → アプリ）

```typescript
interface InvestigationResult {
  // 識別子
  investigation_id: string;
  cr_id: string;
  status: 'completed' | 'partial' | 'failed';
  completed_at: string;            // ISO 8601

  // 探索メタデータ
  exploration_metadata: {
    total_files_scanned: number;
    total_dependencies_found: number;
    max_depth_reached: number;
    truncated: boolean;            // max_files_per_categoryで切られたか
    truncation_reason?: string;
  };

  // 影響ファイル一覧（allow_pathsの素材）
  affected_files: AffectedFile[];

  // 正本との突合結果
  requirements_mapping: RequirementMapping[];

  // 新規発見（正本に登録されていないが影響がありそうなもの）
  discoveries: Discovery[];

  // 疑義候補（自動でsuspect=trueにすべきリンク）
  suspect_candidates: SuspectCandidate[];

  // エージェントの所見（人間向けサマリ）
  summary: {
    high_impact_areas: string[];   // 特に注意すべき領域
    risk_assessment: string;       // リスクの総合評価
    recommended_actions: string[]; // 推奨アクション
  };
}

interface AffectedFile {
  file_path: string;
  impact_type: 'direct' | 'indirect';
  depth: number;                   // entry_pointからの距離
  confidence: number;              // 0.0-1.0
  change_likelihood: 'high' | 'medium' | 'low';
  reason: string;                  // なぜ影響があると判断したか
  
  // 依存関係の詳細
  dependency_chain: string[];      // entry_pointからこのファイルまでのパス
  dependency_type: 'import' | 'type' | 'runtime' | 'config';
  
  // コードスニペット（output.include_file_snippets=trueの場合）
  snippets?: {
    line_start: number;
    line_end: number;
    content: string;
    relevance: string;             // このスニペットが関連する理由
  }[];
}

interface RequirementMapping {
  file_path: string;
  mapped_to: {
    impl_unit_id?: string;         // 既存の実装単位SDにマッピングできた場合
    sf_id?: string;
    sr_ids?: string[];
  };
  mapping_confidence: number;
  mapping_basis: string;           // マッピングの根拠
}

interface Discovery {
  discovery_type: 'unmapped_entry_point' | 'shared_module' | 'unexpected_dependency' | 'circular_dependency';
  file_path: string;
  description: string;
  recommendation: string;          // 正本への登録推奨等
  severity: 'info' | 'warning' | 'critical';
}

interface SuspectCandidate {
  link_id?: string;                // 既存リンクがある場合
  source_id: string;
  target_id: string;
  relation_type: string;
  suspect_reason: string;
  suggested_severity: 'high' | 'medium' | 'low';
  evidence: {
    code_reference?: string;       // 根拠となるコード箇所
    requirement_reference?: string;
  };
}
```

### 6.6 allow\_paths自動決定ロジック

InvestigationResult.affected\_files から allow\_paths を自動生成するルールを定義する。

#### 決定フロー

```
InvestigationResult.affected_files
    ↓ フィルタリング
allow_paths候補
    ↓ 閾値チェック（50ファイル超？）
    ↓ Yes → 影響範囲レビューAI（6.7）
    ↓ No → そのまま採用
allow_paths確定
    ↓
ModificationPackage.execution.allow_paths
```

#### 自動決定ルール

```typescript
interface AllowPathsDecisionRule {
  // 基本ルール：affected_filesから自動生成
  base_rule: {
    include_direct_impacts: true;      // impact_type='direct'は常に含める
    include_indirect_impacts: true;    // impact_type='indirect'も含める
    confidence_threshold: 0.3;         // これ以上のconfidenceのみ
    max_depth: 5;                      // entry_pointからの距離上限
  };

  // 共通処理の扱い
  shared_module_rule: {
    auto_include: true;                // 依存分析で出てきたら自動で含める
    notify_on_include: true;           // 含めた場合は人間に通知
    require_confirmation_if_count_exceeds: 10; // 共通処理が10ファイル超えたら確認要求
  };

  // 安全弁
  safety_limits: {
    max_total_files: 50;               // allow_pathsの最大ファイル数
    max_directories: 10;               // allow_pathsの最大ディレクトリ数
    escalate_if_exceeds: true;         // 超過したら影響範囲レビューAIに回す
  };
}
```

#### 共通処理ディレクトリの定義

プロジェクト設定で以下を定義する。これに該当するファイルは「共通処理」として扱い、通知・確認の対象となる。

```typescript
shared_module_patterns: string[];  // 例: ["src/utils/**", "src/libs/**", "src/shared/**", "src/common/**"]
```

### 6.7 影響範囲レビューAI

allow\_paths候補が閾値（デフォルト50ファイル）を超えた場合、影響範囲レビューAIが起動し、絞り込み提案を行う。

#### ImpactReviewRequest（アプリ → 影響範囲レビューAI）

```typescript
interface ImpactReviewRequest {
  investigation_id: string;
  cr_id: string;

  // レビュー対象
  allow_paths_candidate: string[];
  affected_files: AffectedFile[];  // InvestigationResultから

  // 変更要求の文脈
  change_context: {
    summary: string;
    primary_intent: string;        // 変更の主目的
    out_of_scope: string[];        // 明示的にスコープ外としたいもの
  };

  // レビュー方針
  review_policy: {
    aggressiveness: 'conservative' | 'moderate' | 'aggressive';
    // conservative: 疑わしきは含める（安全重視）
    // moderate: バランス（デフォルト）
    // aggressive: 積極的に絞る（コスト重視）
    
    prioritize_by: 'confidence' | 'depth' | 'change_likelihood';
    target_file_count?: number;    // 目標ファイル数（aggressiveの場合に有効）
  };
}
```

#### ImpactReviewResult（影響範囲レビューAI → アプリ）

```typescript
interface ImpactReviewResult {
  investigation_id: string;
  cr_id: string;

  // 絞り込み結果
  recommended_allow_paths: string[];
  
  // 除外提案
  exclusion_proposals: {
    file_path: string;
    exclusion_reason: string;
    confidence: number;            // 除外しても問題ない確信度
    risk_if_excluded: string;      // 除外した場合のリスク
    decision: 'exclude' | 'include' | 'human_review';
  }[];

  // カテゴリ別サマリ
  category_summary: {
    category: 'core_logic' | 'shared_module' | 'ui_component' | 'api_layer' | 'config' | 'test';
    file_count: number;
    included_count: number;
    excluded_count: number;
    rationale: string;
  }[];

  // 残存リスク
  residual_risks: {
    risk_type: 'missed_dependency' | 'shared_module_side_effect' | 'indirect_impact';
    description: string;
    severity: 'high' | 'medium' | 'low';
    mitigation: string;            // リスク軽減策
  }[];

  // 人間への確認事項
  human_review_items: {
    file_path: string;
    question: string;              // 「このファイルは変更対象に含めるべきですか？」
    context: string;               // 判断材料
    default_recommendation: 'include' | 'exclude';
  }[];
}
```

#### レビューロジックの方針

```typescript
interface ImpactReviewLogic {
  // 除外判定の基準
  exclusion_criteria: {
    // 自動除外（human_review不要）
    auto_exclude: {
      test_files: true;                    // *.test.ts, *.spec.ts
      type_definition_only: true;          // 型定義のみのファイル（*.d.ts）
      config_if_no_schema_change: true;    // スキーマ変更がない設定ファイル
      depth_exceeds: 7;                    // 依存距離が7を超えるもの
      confidence_below: 0.2;               // confidence 0.2未満
    };

    // 条件付き除外（human_review推奨）
    conditional_exclude: {
      shared_module_if_only_type_dependency: true;  // 型依存のみの共通処理
      indirect_impact_if_no_data_flow: true;        // データフローがない間接影響
      ui_component_if_no_prop_change: true;         // props変更がないUIコンポーネント
    };
  };

  // 包含判定の基準
  inclusion_criteria: {
    // 必ず含める
    must_include: {
      direct_entry_point: true;            // 起点のentry_point
      direct_import_of_entry_point: true;  // entry_pointが直接importしているもの
      data_model_change: true;             // データモデル（型、スキーマ）の変更
      api_contract_change: true;           // API契約の変更
    };

    // 優先的に含める
    prefer_include: {
      business_logic_files: true;          // ビジネスロジックを含むファイル
      state_management: true;              // 状態管理（store, context）
      validation_logic: true;              // バリデーションロジック
    };
  };

  // 爆発抑制のヒューリスティクス
  explosion_control: {
    // 同一ディレクトリから大量に出てきた場合
    same_directory_threshold: 10;          // 同一ディレクトリから10ファイル超
    same_directory_action: 'collapse_to_pattern' | 'human_review' | 'sample';
    
    // 共通処理への依存が多すぎる場合
    shared_module_threshold: 15;
    shared_module_action: 'warn_and_include' | 'human_review' | 'exclude_low_confidence';
  };
}
```

### 6.8 改修指示パッケージ設計

要件管理DBアプリが生成し、コーディングエージェントに渡す「改修指示パッケージ」を定義する。目的は、(1) 意図の伝達、(2) スコープの決定論的制約、(3) トレーサビリティの担保である。

```typescript
interface ModificationPackage {
  // 識別子（冪等キー）
  task_id: string;
  cr_id: string;                      // 変更要求ID
  project_id: string;
  repository_url: string;
  base_branch: string;

  // 実行ポリシー
  execution: {
    working_branch: string;          // 例: "agent/{task_id}"
    allow_paths: string[];           // 変更を許可するパス（スコープ強制）
    deny_paths?: string[];           // 明示的に禁止するパス
    max_runtime_sec: number;
    idempotency_key: string;         // 原則 task_id と同値
  };

  // 要件コンテキスト（トレーサビリティ）
  product_requirement: ProductRequirement;  // PR全体（tech_stack_profile含む）
  business_task: string;
  business_requirements: string[];
  system_functions: string[];
  system_requirements: string[];
  acceptance_criteria: string[];

  // 影響調査・レビューの根拠（トレーサビリティ）
  investigation_refs: {
    investigation_id: string;
    investigation_result_summary: string;
    impact_review_id?: string;           // 影響範囲レビューを実施した場合
    impact_review_result_summary?: string;
  };

  // 実装単位SD（対象となる設計情報）
  implementation_units: {
    impl_unit_id: string;
    type: 'screen' | 'api' | 'batch' | 'external_if';
    name: string;
    entry_point: string;
    design_details: Record<string, unknown>;  // api_definition, data_model等
  }[];

  // 改修内容
  modification_summary: string;
  modification_details: string;
  targets: {
    impl_unit_id: string;           // 対象の実装単位SD
    entry_point: string;            // エントリポイントファイルパス
    description: string;
    related_requirements: string[]; // SR/AC ID
  }[];

  // 制約・ガイドライン
  constraints: string[];
  prohibitions: string[];
  coding_guidelines: string;
  test_commands: string[];

  // 残存リスク（PRレビュー時の参考）
  residual_risks?: {
    risk_type: string;
    description: string;
    severity: 'high' | 'medium' | 'low';
    mitigation: string;
  }[];

  // 除外されたファイル（明示的な記録）
  excluded_from_scope?: {
    file_path: string;
    exclusion_reason: string;
    excluded_by: 'auto_rule' | 'ai_review' | 'human_decision';
  }[];
}
```

運用上の原則：

- system\_prompt（または同等の指示）は「意図の伝達」に限定し、「スコープ制限の強制」は allow\_paths/deny\_paths 等の決定論的制約で担保する
- 変更対象（targets）は実装単位SD（impl\_unit\_id）とリンクし、Change PlanやImpact Reportの自動生成に流用する
- investigation\_refs を通じて「どの時点の調査結果に基づいてスコープを決めたか」を再現可能にする
- product\_requirement を含めることで、エージェントがPRのtech_stack_profileやcoding_conventionsを参照できる

### 6.9 ジョブ実行モデル

実行はジョブ（task\_id）として管理し、状態遷移とイベントを永続化する。

- CREATED → RUNNING → SUCCEEDED / FAILED / NEEDS\_REVIEW
- Worker二重起動が起きても「二重コミット」にならないように、idempotency\_key と状態遷移の整合（CAS等）で無害化する

### 6.10 HITL（Human-in-the-Loop）設計

人間の介入ポイントは「判断」ではなく「検証結果の承認」に寄せる。

| フェーズ               | 処理主体               | 人間の関与           |
| ---------------------- | ---------------------- | -------------------- |
| 影響調査ジョブ投入     | 要件管理DBアプリ       | なし（自動）         |
| 影響調査実行           | コーディングエージェント | なし（自動）         |
| 影響範囲レビュー       | 影響範囲レビューAI     | human\_review\_itemsの確認（閾値超過時） |
| 改修指示パッケージ生成 | 要件管理DBアプリ       | 改修内容の確認・承認（任意） |
| 改修実行               | コーディングエージェント | なし（自動）         |
| テスト/静的解析/ビルド | コーディングエージェント | なし（自動）         |
| PR作成                 | コーディングエージェント | なし（自動）         |
| マージ承認             | 人間                   | 必須                 |
| 検証失敗時             | エスカレーション       | 必須（例外対応）     |

マージ承認の負荷を下げるため、PR作成時に以下を必須成果物として添付する。

| 成果物                         | 目的                                   |
| ------------------------------ | -------------------------------------- |
| Change Plan（変更計画）        | 何をどう変えたかを実装単位SD IDと紐付けて列挙 |
| Impact Report（影響調査）      | 依存・影響範囲・リスクを列挙（自動生成） |
| Verification Summary（検証要約） | テスト/静的解析/ビルドの結果を集約     |
| Residual Risks（残存リスク）   | 影響範囲レビューで検出されたリスク     |

### 6.11 Hooks設計（ガードレール）

Hooksは「決定論的なガードレール」として使用し、ワークフロー制御（テスト実行等）には使用しない。

- Bashは許可コマンド集合（allowlist）に一致する場合のみ実行
- ファイル編集は allow\_paths に含まれる場合のみ許可
- deny\_paths と機密ファイルは常に禁止

テスト実行はオーケストレーション層（アプリケーションコード）で制御する。

### 6.12 通信設計

実行制御はHTTPのジョブAPIを主軸とし、進捗表示のためにイベントストリームを用意する。

```
POST   /api/tasks                  # タスク作成（冪等）
GET    /api/tasks/{task_id}        # 状態参照
GET    /api/tasks/{task_id}/events # イベント取得（SSE or pagination）
POST   /api/tasks/{task_id}/retry  # リトライ指示（将来拡張）
```

- WebSocket/SSEは「イベント配信」に限定し、状態の正は永続ストアに置く
- クライアントは last\_event\_id を指定して欠損分を復元できる

### 6.13 エラーハンドリングとエスカレーション

| 失敗パターン   | 検知方法                          | 対応           |
| -------------- | --------------------------------- | -------------- |
| 影響調査失敗   | Workerの実行結果                  | エスカレーション |
| 改修実行失敗   | Workerの実行結果                  | エスカレーション |
| テスト失敗     | 終了コード・出力解析              | エスカレーション |
| 静的解析エラー | Lint/型チェックの終了コード       | エスカレーション |
| ビルド失敗     | ビルドコマンドの終了コード        | エスカレーション |
| スコープ外変更 | allow\_paths と実際のdiff比較     | エスカレーション |
| タイムアウト   | max\_runtime\_sec 到達            | エスカレーション |
| 二重実行       | idempotency\_key / 状態遷移整合   | 無害化（片方をNOOP） |

失敗時は TaskStatus.NEEDS\_REVIEW に更新し、要件管理DBアプリ側のチャットUIにレビュー要求として表示する。

### 6.14 セキュリティ

- サンドボックス化：ワークスペース外へのアクセス禁止、リソース制限、実行時間制限
- ネットワーク制限：許可ドメインのみ接続可能（egress allowlist）
- 認証・認可：サービス間はOIDC/JWT等で認証し、GitHub連携はGitHub App（最小権限・短命トークン）で運用する
- Secret管理：LLM APIキー等はSecret Manager等で管理し、Personal Access Tokenの運用は避ける

### 6.15 プロジェクト設定

影響調査・allow\_paths決定・影響範囲レビューの挙動をプロジェクト単位で設定する。

```typescript
interface ProjectInvestigationSettings {
  // 探索設定
  exploration: {
    default_max_depth: number;           // デフォルト: 5
    default_include_patterns: string[];
    default_exclude_patterns: string[];
  };

  // allow_paths決定ルール
  allow_paths_rule: AllowPathsDecisionRule;

  // 影響範囲レビュー設定
  impact_review: {
    auto_trigger_threshold: number;      // この数を超えたら自動でレビュー起動（デフォルト: 50）
    default_aggressiveness: 'conservative' | 'moderate' | 'aggressive';
    require_human_confirmation: boolean; // human_review_itemsを必須にするか
  };

  // 共通処理ディレクトリの定義
  shared_module_patterns: string[];      // 例: ["src/utils/**", "src/libs/**", "src/shared/**"]
}
```

### 6.16 実装ロードマップ

| Phase           | 主な内容                                                                                                                               |
| --------------- | -------------------------------------------------------------------------------------------------------------------------------------- |
| Phase 1: MVP    | InvestigationRequest/Result、改修指示パッケージ生成、タスク管理（状態/イベント永続化、冪等POST）、Worker実行、スコープ外変更検知、基本Hooks、テスト実行・PR作成、イベント配信（SSEまたはポーリング） |
| Phase 2: 品質向上 | 影響範囲レビューAI、チャットUI統合、影響範囲チェック精度向上（依存解析導入）、エスカレーションフロー整備、監査ログ/メトリクス収集                           |
| Phase 3: 拡張   | 対話的改修（追加指示）、サブエージェント分離、分析→計画→再実行の自動リトライ、WebSocket配信高度化                                       |

### 6.17 決定事項サマリ

| 論点         | 決定                                        | 理由                             |
| ------------ | ------------------------------------------- | -------------------------------- |
| ジョブ種別   | 影響調査ジョブと改修ジョブを分離            | 役割と制約が異なるため明確に分ける |
| allow\_paths決定 | 依存分析で出たファイルは自動で含める + 閾値超過時はレビューAI | 安全性とコストのバランス |
| 実行モデル   | ジョブ（永続状態）+ エフェメラル実行        | 切断・再実行・冪等を前提化       |
| HITL設計     | マージ承認のみ人間、他は自動（閾値超過時のレビュー除く） | 判断のブレを排除しつつ責任分界を明確化 |
| Hooksの用途  | ガードレール（allowlist + パス制約）に限定  | ワークフロー制御はアプリ層で行う |
| 通信方式     | HTTP（ジョブAPI）+ イベント配信（SSE/WebSocket） | 実行制御と表示を分離して堅牢化   |
| GitHub 認証  | GitHub App（最小権限・短命トークン）        | 運用事故を下げる                 |

### 6.18 用語

| 用語               | 定義                                                           |
| ------------------ | -------------------------------------------------------------- |
| InvestigationRequest | 影響調査ジョブの入力。探索起点、探索制約、変更要求の文脈を含む |
| InvestigationResult | 影響調査ジョブの出力。影響ファイル一覧、正本との突合結果、疑義候補を含む |
| 改修指示パッケージ | 改修ジョブの入力。改修に必要な全コンテキストを含む構造化データ |
| 影響範囲レビューAI | allow\_paths候補が爆発した場合に絞り込みを行うAIエージェント |
| オーケストレーション層 | コーディングエージェントの実行フロー（改修→検証→PR作成）を制御するアプリケーションコード |
| エスカレーション   | 自動処理が失敗した場合に人間の介入を要求するプロセス           |
| ジョブ（task）     | 実行単位。状態とイベントを永続化し、冪等性を担保する           |

---

## 7. エクスポート仕様（Claude Code連携）

本章は、本ツールの正本をClaude Codeが参照できる形式で出力する仕様を定義する。

### 7.1 出力ファイル構成

```
docs/requirements/
  INDEX.md                           - ルーティング表（全体の目次）
  product-requirement.yml            - プロダクト要件（PR）
  concept-dictionary.yml             - 概念辞書

  business/                          # 業務側の正本
    {業務分類ID}/
      _index.md                      # 業務分類の概要
      {業務タスクID}.md              # 業務タスク＋業務要件

  system/                            # システム側の正本
    {システム領域ID}/
      _index.md                      # システム領域の概要
      {システム機能ID}.md            # システム機能＋システム要件＋実装単位SD

  graph/
    requirements-links.json          # 業務要件↔システム要件のリンク（根拠データ含む）

  VERSION.md                         - エクスポート時点の版情報
```

ディレクトリ構成の意図：

| ディレクトリ | 内容 | Claude Codeの利用シーン |
|-------------|------|------------------------|
| `product-requirement.yml` | プロダクト要件（PR） | tech_stack_profile、coding_conventionsを参照して実装方針を決める |
| `business/` | 業務タスク・業務要件 | 「なぜこの変更が必要か」の業務文脈を理解する |
| `system/` | システム機能・システム要件・実装単位SD | 「どのファイルを修正すべきか」を特定する |
| `graph/` | 要件間のリンクと根拠 | 影響範囲の波及を辿る |

### 7.2 プロダクト要件ファイルフォーマット

`product-requirement.yml`

```yaml
pr_id: PR-001

target_users: |
  中小企業の経理担当者。会計ソフトの基本操作は理解している。
  月次決算、請求書発行、入金消込を日常業務として行う。

experience_goals: |
  - 請求書発行から入金消込までの一連の流れをストレスなく完了できる
  - 月次決算の締め作業を半日以内に完了できる
  - 取引先ごとの債権状況を一目で把握できる

quality_goals: |
  - 応答時間：主要操作は3秒以内（P95）
  - 可用性：99.5%（月間ダウンタイム3.6時間以内）
  - セキュリティ：SOC2 Type II準拠

design_system: |
  - カラー：プライマリ#3B82F6、セカンダリ#10B981、エラー#EF4444
  - タイポグラフィ：本文14px/1.6、見出しはInter
  - コンポーネント：shadcn/uiベース

ux_guidelines: |
  - 操作結果は即座にフィードバック（トースト通知）
  - 破壊的操作は確認ダイアログ必須
  - エラーメッセージは原因と対処法を明示

tech_stack_profile:
  policy:
    unspecified_fields: agent_decides
  frontend:
    framework: Next.js
    language: TypeScript
    styling: Tailwind
    ui_library: shadcn/ui
  backend:
    runtime: Node.js
    framework: Hono
  database:
    provider: Supabase
  auth:
    provider: BetterAuth
  constraints:
    must_use:
      - Supabase Row Level Security
      - Zod
    must_not_use:
      - jQuery
      - Moment.js
    notes: |
      モノレポ（Turborepo）で管理。
      パッケージマネージャはpnpm。

coding_conventions:
  naming:
    files: kebab-case
    components: PascalCase
    functions: camelCase
  directory_structure:
    pattern: feature-based
  testing:
    unit_test_pattern: "*.test.ts"
    coverage_target: 80%
    test_runner: vitest
```

### 7.3 業務タスクファイルフォーマット

`business/{業務分類ID}/{業務タスクID}.md`

```yaml
---
id: BT-BIL-001
title: 請求書発行
business_domain_id: BD-BIL
business_domain_name: 請求
---

## 概要

請求書を発行し、顧客へ送付するまでの業務フロー。

## 業務要件

### BR-BIL-001: 請求書をPDFで出力できる

#### 関連システム要件
- [SR-BIL-001](../../system/SD-BIL/SF-BIL-010.md#sr-bil-001)
- [SR-BIL-002](../../system/SD-BIL/SF-BIL-010.md#sr-bil-002)

#### 関連概念
- TAX_INVOICE_JP
```

### 7.4 システム機能ファイルフォーマット

`system/{システム領域ID}/{システム機能ID}.md`

```yaml
---
id: SF-BIL-010
title: 請求書出力バッチ
system_domain_id: SD-BIL
system_domain_name: SD請求
---

## 概要

請求書PDFを生成するバッチ処理。月次締め後に実行される。

## 実装単位SD

### IU-BIL-010-01: 請求書PDF生成ジョブ

- type: batch
- entry_point: /jobs/invoice-pdf-batch.ts
- responsibility: PDF生成、税計算、登録番号出力

### IU-BIL-010-02: 請求書発行画面

- type: screen
- entry_point: /app/billing/invoice/page.tsx
- responsibility: 発行指示、一覧表示

## システム要件

### SR-BIL-001: 請求書PDFに登録番号と税率別合計を出力

#### 受入基準
- 登録番号が帳票右上に印字されていること
- 税率ごとの合計金額が明細の下に表示されること

#### 関連業務要件
- [BR-BIL-001](../../business/BD-BIL/BT-BIL-001.md#br-bil-001)

#### 関連概念
- TAX_INVOICE_JP
```

### 7.5 概念辞書フォーマット

`concept-dictionary.yml`

```yaml
TAX_INVOICE_JP:
  name: 適格請求書
  synonyms: [インボイス, 登録番号, 税率ごとの対価]
  system_domains: [SD-BIL, SD-FI]
  must_read:
    - system/SD-BIL/SF-BIL-010.md
    - system/SD-FI/SF-FI-020.md
```

### 7.6 リンク・根拠データフォーマット

`graph/requirements-links.json`

要件間のリンクと疑義状態を一元管理する。4.4で定義した suspect 状態もこのファイルで管理し、UI・API・エージェント参照の唯一の根拠とする。

```json
{
  "links": [
    {
      "link_id": "LNK-001",
      "source": "BR-BIL-001",
      "source_type": "business_requirement",
      "target": "SR-BIL-001",
      "target_type": "system_requirement",
      "relation_type": "realizes",
      "evidence": {
        "matched_concepts": ["TAX_INVOICE_JP"],
        "reason": "請求書PDF出力の業務要件を実現するためのシステム要件"
      },
      "last_confirmed": "2025-01-17T12:00:00Z",
      "suspect": false,
      "suspect_severity": null,
      "suspect_reason": null,
      "evidence_refs": []
    },
    {
      "link_id": "LNK-002",
      "source": "SR-BIL-001",
      "source_type": "system_requirement",
      "target": "SR-FI-003",
      "target_type": "system_requirement",
      "relation_type": "depends_on",
      "evidence": {
        "matched_concepts": ["TAX_INVOICE_JP"],
        "source_field": "summary",
        "source_span": "消費税調整仕訳",
        "reason": "SD請求でインボイス対応するとFI税務仕訳にも影響"
      },
      "last_confirmed": "2025-01-17T12:00:00Z",
      "suspect": true,
      "suspect_severity": "medium",
      "suspect_reason": "SR-FI-003の税率計算ロジックが改訂された",
      "evidence_refs": ["investigation_id:INV-2025-001", "commit:abc123"]
    }
  ]
}
```

リンクフィールド定義：

| フィールド | 必須 | 説明 |
|-----------|------|------|
| link\_id | ○ | リンクの一意識別子 |
| source | ○ | 参照元のID |
| source\_type | ○ | 参照元の種別（business\_requirement / system\_requirement / system\_function / impl\_unit\_sd） |
| target | ○ | 参照先のID |
| target\_type | ○ | 参照先の種別 |
| relation\_type | ○ | リンクの種別（realizes / depends\_on / derives\_from / conflicts\_with） |
| evidence | ○ | リンクの根拠（matched\_concepts、reason等） |
| last\_confirmed | ○ | 最終確認日時 |
| suspect | ○ | 疑義があるか（true = レビュー待ち） |
| suspect\_severity | - | 疑義の重大度（high / medium / low）。suspect=true の場合のみ設定 |
| suspect\_reason | - | 疑義の理由。suspect=true の場合のみ設定 |
| evidence\_refs | - | 疑義や確認の根拠を指す参照の配列 |

relation\_type の定義（4.4で確定した最小セット）：

| type | 意味 |
|------|------|
| realizes | 業務要件をシステム要件が実現する |
| depends\_on | 前提として依存する |
| derives\_from | 派生・詳細化する |
| conflicts\_with | 矛盾する可能性がある |

### 7.7 INDEX.md（ルーティング表）

Claude Codeが最初に読むべきファイル。全体構成と参照方法を示す。

```markdown
# 要件正本 INDEX

## 構成

- `product-requirement.yml` - プロダクト要件（技術スタック、コーディング規約）
- `business/` - 業務タスク・業務要件（なぜこの機能が必要か）
- `system/` - システム機能・システム要件・実装単位SD（どう実装されているか）
- `graph/requirements-links.json` - 要件間のリンクと根拠
- `concept-dictionary.yml` - 用語辞書（同義語・影響範囲）

## 参照手順

1. まず `product-requirement.yml` を読み、技術スタックとコーディング規約を確認
2. 変更要求の内容から、関連する概念を`concept-dictionary.yml`で検索
3. 概念の`must_read`に記載されたシステム機能ファイルを読む
4. システム機能ファイルの実装単位SDから`entry_point`を特定
5. 必要に応じて`graph/requirements-links.json`で波及影響を確認

## 業務分類一覧

| ID | 名称 | ファイル |
|----|------|---------|
| BD-BIL | 請求 | [business/BD-BIL/_index.md](business/BD-BIL/_index.md) |

## システム領域一覧

| ID | 名称 | ファイル |
|----|------|---------|
| SD-BIL | SD請求 | [system/SD-BIL/_index.md](system/SD-BIL/_index.md) |
```

### 7.8 Claude Code Skill連携

Claude Codeの`.claude/skills/`にSKILL.mdを配置し、「まずproduct-requirement.ymlを読み、次にINDEX.mdを読み、概念辞書でヒットしたmust_readを読む」手順を提案する。

```markdown
# 要件正本参照スキル

## 概要
このプロジェクトには構造化された要件正本があります。変更を行う前に必ず参照してください。

## 参照手順
1. `docs/requirements/product-requirement.yml` を読み、技術スタックとコーディング規約を確認
2. `docs/requirements/INDEX.md` を読む
3. 変更内容に関連する概念を `concept-dictionary.yml` で検索
4. 概念の `must_read` に記載されたファイルを読む
5. システム機能ファイルの実装単位SDから `entry_point` を確認
6. 受入基準を確認し、何を満たせばOKか理解する

## 注意
- 実装時は `product-requirement.yml` の `tech_stack_profile` と `coding_conventions` に従う
- 影響範囲が不明な場合は `graph/requirements-links.json` で波及を確認
- 受入基準を満たさない変更は行わない
```

---


## 8. 技術アーキテクチャ

本章では、要件管理DBアプリの技術的な構成を定義する。5章で設計したアプリ内AI、6章で設計したコーディングエージェント連携を含めた全体像を示し、各層の技術選定と責務を明確にする。

---

### 8.1 アーキテクチャ全体像

要件管理DBアプリは、3つの層で構成される。

```
┌─────────────────────────────────────────────────────────────────────────┐
│                        要件管理DBシステム全体像                          │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  ┌───────────────────────────────────────────────────────────────────┐  │
│  │ ① アプリケーション層                                              │  │
│  │    正本の管理UI、レビューUI、エクスポート                          │  │
│  │    [Next.js + Supabase]                                           │  │
│  └───────────────────────────────────────────────────────────────────┘  │
│                                    │                                    │
│                                    │ API呼び出し                        │
│                                    ▼                                    │
│  ┌───────────────────────────────────────────────────────────────────┐  │
│  │ ② アプリ内AI層                                                    │  │
│  │    登録支援、影響調査、品質チェック（チャットUI経由）               │  │
│  │    [Mastra Agent + Tool群]（5章参照）                              │  │
│  └───────────────────────────────────────────────────────────────────┘  │
│                                    │                                    │
│                                    │ ジョブ投入 / 結果受信              │
│                                    ▼                                    │
│  ┌───────────────────────────────────────────────────────────────────┐  │
│  │ ③ コーディングエージェント連携層                                   │  │
│  │    コード解析、影響調査、改修実行                                   │  │
│  │    [Claude Agent SDK + MCP Server]（6章参照）                      │  │
│  └───────────────────────────────────────────────────────────────────┘  │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

各層の責務：

| 層 | 責務 | 主な機能 |
|----|------|---------|
| アプリケーション層 | 正本の永続化、UI提供、エクスポート | CRUD画面、レビューUI、疑義リンク受信箱、Claude Code連携ファイル出力 |
| アプリ内AI層 | 登録支援、品質チェック、影響分析（正本ベース） | チャットUI、草案生成、Criticチェック、トップダウン分析 |
| コーディングエージェント連携層 | コード解析、影響調査（コードベース）、改修実行 | InvestigationRequest処理、ModificationPackage処理、PR作成 |

この3層構成により、「正本の管理」「AIによる支援」「コーディングエージェントとの連携」を明確に分離し、各層を独立して進化させられる。

---

### 8.2 技術選定

### 選定一覧

| コンポーネント | 技術 | 選定理由 |
|---------------|------|---------|
| フロントエンド | Next.js 16 (App Router) | PRで指定された技術スタック |
| UIライブラリ | shadcn/ui + Tailwind | PRで指定、コンポーネント豊富 |
| バックエンド | Hono (on Supabase Edge Functions) | 軽量、TypeScript、Edge対応 |
| データベース | Supabase (PostgreSQL) | RLS、リアルタイム、Auth統合 |
| ベクトル検索 | pgvector | 概念辞書の類似検索、Supabase統合 |
| アプリ内AI | Mastra | Agent/Tool/Workflow統合、5章で設計 |
| LLM | Claude (Anthropic API) | 高精度、構造化出力、日本語対応 |
| コーディングエージェント | Claude Agent SDK | 6章で設計、MCP対応 |
| Agent Runner | Cloud Run | ジョブ実行基盤、スケーラブル |
| 認証 | BetterAuth | Supabase Auth代替、柔軟なプロバイダ対応 |
| ホスティング | Vercel | Next.js最適化、Edge Functions |

### 選定の背景

フロントエンドとバックエンドはPR（3.1参照）のtech_stack_profileで定義されたスタックに従う。本ツール自体が「PRに従って開発する」実践例となる。

アプリ内AIにMastraを採用する理由は5章で説明した通り、「単一Agent + 複数Tool」の構成を自然に実装でき、コンテキスト管理とワークフロー定義が容易なため。

コーディングエージェントにClaude Agent SDKを採用する理由は6章で説明した通り、MCP対応によりアプリの正本に直接アクセスでき、サブエージェント機能で複雑なタスクを分解できるため。

---

### 8.3 アプリケーション層

### フロントエンド構成

```
/app
  /product-requirement    # PR編集
  /business               # 業務領域・BT・BR管理
  /system                 # システム領域・SF・SR・実装単位SD管理
  /concepts               # 概念辞書管理
  /change-requests        # CR・影響調査・疑義リンク管理
  /chat                   # AIチャットUI（Mastra Agent）
  /settings               # プロジェクト設定
  /projects               # プロジェクト一覧
```

UIはshadcn/uiをベースに、以下のパターンで構成する。

| パターン | 用途 | コンポーネント例 |
|---------|------|----------------|
| 一覧画面 | BD/SD/CR等の一覧表示 | DataTable, Card |
| 詳細画面 | 要件の詳細表示・編集 | Form, Tabs, Sheet |
| チャット画面 | アプリ内AIとの対話 | Chat UI（カスタム） |
| レビュー画面 | 草案の確認・編集 | Diff View, Accordion |

### バックエンド構成

APIはHono on Supabase Edge Functionsで提供する。

| エンドポイント群 | 責務 |
|-----------------|------|
| /api/requirements/* | 要件CRUD（BD/BT/BR/SD/SF/SR/AC/実装単位SD） |
| /api/concepts/* | 概念辞書CRUD |
| /api/links/* | 要件間リンクCRUD、疑義管理 |
| /api/change-requests/* | CR管理、影響調査結果 |
| /api/export/* | エクスポート（7章形式） |
| /api/agent/* | Mastra Agentへの橋渡し |

### データベース設計

主要テーブル：

| テーブル | 内容 |
|---------|------|
| projects | プロジェクト |
| product_requirements | PR（プロジェクトごとに1件） |
| business_domains | 業務領域（BD） |
| business_tasks | 業務タスク（BT） |
| business_requirements | 業務要件（BR） |
| system_domains | システム領域（SD） |
| system_functions | システム機能（SF） |
| system_requirements | システム要件（SR） |
| acceptance_criteria | 受入基準（AC） |
| impl_unit_sds | 実装単位SD |
| concepts | 概念辞書 |
| requirement_links | 要件間リンク（疑義管理含む） |
| change_requests | 変更要求（CR） |
| investigation_results | 影響調査結果 |
| design_decisions | 設計決定ログ |

Row Level Security（RLS）でプロジェクト単位のアクセス制御を行う。

---

### 8.4 アプリ内AI層

5章で設計した統合Agent（Mastra）の技術的な配置を定義する。

### 配置構成

```
┌────────────────────────────────────────────────────────────────┐
│ Next.js アプリケーション                                        │
│                                                                │
│  ┌──────────────┐      ┌──────────────────────────────────┐   │
│  │ チャットUI    │ ───▶ │ /api/agent/chat                  │   │
│  │ (React)      │      │ (API Route)                      │   │
│  └──────────────┘      └──────────────┬───────────────────┘   │
│                                       │                       │
│                                       ▼                       │
│                        ┌──────────────────────────────────┐   │
│                        │ Mastra Agent                     │   │
│                        │ (サーバーサイドで実行)            │   │
│                        │                                  │   │
│                        │  ┌────────────────────────────┐  │   │
│                        │  │ Tool群                     │  │   │
│                        │  │ - bt_draft                 │  │   │
│                        │  │ - br_draft                 │  │   │
│                        │  │ - system_draft             │  │   │
│                        │  │ - impact_analysis          │  │   │
│                        │  │ - critic_check             │  │   │
│                        │  │ - ...                      │  │   │
│                        │  └────────────────────────────┘  │   │
│                        └──────────────┬───────────────────┘   │
│                                       │                       │
│                                       ▼                       │
│                        ┌──────────────────────────────────┐   │
│                        │ Supabase (正本DB)                │   │
│                        └──────────────────────────────────┘   │
│                                                                │
└────────────────────────────────────────────────────────────────┘
```

### Mastra Agent の初期化

```typescript
// /lib/mastra/agent.ts
import { Agent } from '@mastra/core';
import { tools } from './tools';

export const requirementsAgent = new Agent({
  name: 'requirements-agent',
  instructions: `...`, // 5.2参照
  model: {
    provider: 'anthropic',
    name: 'claude-sonnet-4-20250514',
  },
  tools,
});
```

### Tool群の実装パターン

各Toolは以下のパターンで実装する。

```typescript
// /lib/mastra/tools/bt-draft.ts
import { createTool } from '@mastra/core';
import { z } from 'zod';
import { supabase } from '@/lib/supabase';

export const btDraftTool = createTool({
  id: 'bt_draft',
  description: '業務タスク（BT）の草案を生成する',
  inputSchema: z.object({
    naturalLanguageInput: z.string(),
    bdId: z.string(),
  }),
  execute: async ({ naturalLanguageInput, bdId }, { context }) => {
    // 1. 正本からコンテキスト取得
    const pr = await supabase.from('product_requirements').select('*').single();
    const existingBTs = await supabase.from('business_tasks').select('*').eq('bd_id', bdId);
    
    // 2. LLMで草案生成（Mastraの内部LLM呼び出し）
    // ...
    
    // 3. 草案を返却（DBには保存しない）
    return { draft, uncertainties };
  },
});
```

### セッション管理

チャットセッションはMastraのMemory機能で管理し、以下のコンテキストを保持する。

| コンテキスト | 保持期間 | 用途 |
|-------------|---------|------|
| PR | セッション開始時に注入 | 技術スタック、コーディング規約の参照 |
| 現在位置 | セッション中更新 | 親要件の自動設定 |
| 未確定草案 | セッション終了まで | 連続作業の文脈維持 |
| 会話履歴 | セッション終了まで | 対話の継続 |

---

### 8.5 コーディングエージェント連携層

6章で設計したコーディングエージェント連携の技術的な配置を定義する。

### 配置構成

```
┌────────────────────────────────────────────────────────────────────┐
│ 要件管理DBアプリ                                                   │
│                                                                    │
│  ┌──────────────────┐      ┌──────────────────────────────────┐   │
│  │ CR詳細画面        │ ───▶ │ /api/jobs/investigation          │   │
│  │ (影響調査ボタン)  │      │ (ジョブ投入API)                   │   │
│  └──────────────────┘      └──────────────┬───────────────────┘   │
│                                           │                       │
└───────────────────────────────────────────┼───────────────────────┘
                                            │ ジョブ投入
                                            ▼
┌────────────────────────────────────────────────────────────────────┐
│ Agent Runner (Cloud Run)                                           │
│                                                                    │
│  ┌──────────────────────────────────────────────────────────────┐  │
│  │ Claude Agent SDK                                             │  │
│  │                                                              │  │
│  │  ┌────────────────────────────────────────────────────────┐  │  │
│  │  │ MCP Client                                             │  │  │
│  │  │ - 正本API (MCP Server) への接続                        │  │  │
│  │  │ - 対象リポジトリへのアクセス                            │  │  │
│  │  └────────────────────────────────────────────────────────┘  │  │
│  │                                                              │  │
│  │  ┌────────────────────────────────────────────────────────┐  │  │
│  │  │ ジョブ実行                                             │  │  │
│  │  │ - InvestigationRequest → InvestigationResult           │  │  │
│  │  │ - ModificationPackage → 実装 → PR作成                  │  │  │
│  │  └────────────────────────────────────────────────────────┘  │  │
│  └──────────────────────────────────────────────────────────────┘  │
│                                                                    │
└────────────────────────────────────────────────────────────────────┘
                                            │
                                            │ MCP Protocol
                                            ▼
┌────────────────────────────────────────────────────────────────────┐
│ MCP Server (要件管理DBアプリ内)                                    │
│                                                                    │
│  提供ツール:                                                       │
│  - get_product_requirement                                         │
│  - search_requirements                                             │
│  - get_requirement                                                 │
│  - get_system_function                                             │
│  - get_links                                                       │
│  - submit_investigation_result                                     │
│                                                                    │
└────────────────────────────────────────────────────────────────────┘
```

### MCP Server の実装

MCP Serverは、コーディングエージェントが正本にアクセスするためのインターフェースを提供する。

```typescript
// /lib/mcp/server.ts
import { MCPServer, Tool } from '@modelcontextprotocol/sdk';

const tools: Tool[] = [
  {
    name: 'get_product_requirement',
    description: 'プロダクト要件（PR）を取得',
    inputSchema: { type: 'object', properties: {} },
    handler: async () => {
      const pr = await supabase.from('product_requirements').select('*').single();
      return pr;
    },
  },
  {
    name: 'search_requirements',
    description: '要件を検索',
    inputSchema: {
      type: 'object',
      properties: {
        query: { type: 'string' },
        type: { type: 'string', enum: ['business', 'system'] },
      },
      required: ['query'],
    },
    handler: async ({ query, type }) => {
      // ベクトル検索 + 全文検索
      // ...
    },
  },
  // ... 他のツール
];

export const mcpServer = new MCPServer({ tools });
```

### ジョブ管理

ジョブは以下の状態を持つ。

```
pending → running → completed
                 → failed
                 → cancelled
```

ジョブの状態と結果はSupabaseに永続化し、UIからリアルタイムで監視できる。

---

### 8.6 セキュリティ

### 認証・認可

| 対象 | 方式 | 説明 |
|------|------|------|
| ユーザー認証 | BetterAuth | メール/パスワード、OAuth（GitHub等） |
| API認証（アプリ内） | セッションベース | BetterAuthのセッション |
| API認証（MCP Server） | APIキー | プロジェクトごとに発行 |
| DB認可 | RLS | プロジェクト単位のアクセス制御 |

### 権限モデル

組織→プロジェクト→ユーザーの3層構造で権限を管理する。

```
組織（Organization）
  └── プロジェクト（Project）
        └── メンバー（User + Role）
```

ロール定義：

| ロール | 説明 | 権限 |
|--------|------|------|
| owner | 組織オーナー | 組織設定、プロジェクト作成・削除、メンバー管理、全操作 |
| admin | プロジェクト管理者 | プロジェクト設定、メンバー招待、全要件の編集・削除 |
| editor | 編集者 | 要件の作成・編集、CR起票、影響調査実行 |
| viewer | 閲覧者 | 要件の閲覧のみ、編集不可 |

操作別の権限マトリクス：

| 操作 | owner | admin | editor | viewer |
|------|:-----:|:-----:|:------:|:------:|
| 組織設定 | ○ | - | - | - |
| プロジェクト作成・削除 | ○ | - | - | - |
| プロジェクト設定 | ○ | ○ | - | - |
| メンバー管理 | ○ | ○ | - | - |
| 要件の閲覧 | ○ | ○ | ○ | ○ |
| 要件の作成・編集 | ○ | ○ | ○ | - |
| 要件の削除 | ○ | ○ | - | - |
| CR起票・影響調査 | ○ | ○ | ○ | - |
| 改修指示パッケージ生成 | ○ | ○ | ○ | - |
| エクスポート | ○ | ○ | ○ | ○ |

MVPスコープ：MVPではowner/editorの2ロールで開始し、admin/viewerは将来拡張とする。

### データ保護

| 観点 | 対策 |
|------|------|
| 通信の暗号化 | HTTPS必須 |
| 保存時の暗号化 | Supabaseのデフォルト暗号化 |
| 機密情報の分離 | APIキー等はVault（将来拡張） |

### コーディングエージェントへのデータ送信

コーディングエージェントに送信される正本データは、以下のルールで制御する。

| ルール | 説明 |
|--------|------|
| 送信範囲の可視化 | UIで「どの正本がエージェントに送られるか」を表示 |
| 機密フラグ（将来） | 機密性の高い要件には「送信不可」フラグを設定可能 |
| ログ記録 | エージェントへの送信内容を監査ログに記録 |

---

### 8.7 コスト管理

### コスト発生ポイント

| コンポーネント | 課金単位 | 主なコスト要因 |
|---------------|---------|---------------|
| Anthropic API（Mastra経由） | トークン | 草案生成、品質チェック |
| Anthropic API（Agent SDK経由） | トークン | 影響調査、改修実行 |
| Supabase | ストレージ、リクエスト | 正本保存、API呼び出し |
| Vercel | 関数実行時間 | API処理 |
| Cloud Run | CPU時間 | Agent Runner |

### トークン消費の目安

| 操作 | 想定トークン | 備考 |
|------|-------------|------|
| BT草案生成 | 1,000〜3,000 | 入力の長さに依存 |
| SF/SR/AC一括生成 | 3,000〜8,000 | BR数に依存 |
| 品質チェック | 1,000〜3,000 | チェック対象数に依存 |
| 影響調査（コード解析） | 5,000〜15,000 | リポジトリ規模に依存 |
| 改修実行（1ファイル） | 5,000〜20,000 | 変更内容に依存 |

### コスト最適化の方針

| 方針 | 効果 |
|------|------|
| 段階的な深掘り | 最初は浅い分析、必要に応じて深掘り |
| 正本の充実 | 正本が充実するほどコード分析の範囲を絞れる |
| キャッシュ活用 | 同一セッション内の重複クエリをキャッシュ |
| モデル使い分け | 簡単なタスクはHaiku、複雑なタスクはSonnet |

### 予算管理（将来拡張）

- プロジェクトごとの月額上限設定
- 上限到達時の警告・制限
- 使用量ダッシュボード

---

## 9. 画面構成と利用フロー

本章では、要件管理DBアプリの画面構成と、想定する利用フローを定義する。8章が「どう作るか」を定義したのに対し、本章は「どう使うか」を定義する。

---

### 9.1 画面一覧

### サイドメニュー構成

| メニュー | 説明 | 主な操作 |
|---------|------|---------|
| プロダクト要件 | PR（技術スタック、品質目標等）の管理 | 編集 |
| 業務一覧 | 業務領域（BD）と配下のBT/BRの管理 | 一覧、追加、編集、AI登録 |
| システム領域一覧 | システム領域（SD）と配下のSF/SR/実装単位SDの管理 | 一覧、追加、編集、AI登録 |
| 概念一覧 | 概念辞書の管理 | 一覧、追加、編集、未処理確認 |
| 変更要求一覧 | CR、影響調査、疑義リンクの管理 | 一覧、起票、調査、レビュー |
| AIアシスタント | チャットUIでの登録支援 | チャット、草案確認 |
| 設定 | プロジェクト設定、エクスポート | 設定変更、ファイル出力 |
| プロジェクト一覧 | プロジェクト切り替え | 選択、新規作成 |

### URL構成

```
/
├── product-requirement          # PR編集
├── business/                    # 業務領域
│   ├── [bd_id]/                 # BD詳細 + BT一覧
│   │   └── bt/
│   │       └── [bt_id]/         # BT詳細 + BR一覧
├── system/                      # システム領域
│   ├── [sd_id]/                 # SD詳細 + SF一覧
│   │   └── sf/
│   │       └── [sf_id]/         # SF詳細 + SR/実装単位SD一覧
├── concepts/                    # 概念一覧
│   └── [concept_id]/            # 概念詳細
├── change-requests/             # CR一覧
│   └── [cr_id]/                 # CR詳細・影響調査・疑義リンク
├── chat/                        # AIチャットUI
├── settings/                    # プロジェクト設定
└── projects/                    # プロジェクト一覧
```

---

### 9.2 主要画面の構成

### プロダクト要件画面（/product-requirement）

PRを編集する画面。プロジェクト開始時に最初に設定し、以降は重要な方針変更時のみ更新する。

```
┌─────────────────────────────────────────────────────────────────────┐
│ プロダクト要件                                           [保存]    │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  [基本情報] [デザイン・UX] [技術スタック] [コーディング規約]         │
│  ─────────────────────────────────────────────────────────────────  │
│                                                                     │
│  ┌─────────────────────────────────────────────────────────────┐   │
│  │ 基本情報                                                    │   │
│  │                                                             │   │
│  │ ターゲットユーザー                                          │   │
│  │ ┌─────────────────────────────────────────────────────┐    │   │
│  │ │ ERP導入コンサルタント、少人数開発チーム              │    │   │
│  │ └─────────────────────────────────────────────────────┘    │   │
│  │                                                             │   │
│  │ 体験目標                                                    │   │
│  │ ┌─────────────────────────────────────────────────────┐    │   │
│  │ │ 要件の「書き方」を考えなくて済む状態を作る          │    │   │
│  │ └─────────────────────────────────────────────────────┘    │   │
│  │                                                             │   │
│  │ 品質目標                                                    │   │
│  │ ┌─────────────────────────────────────────────────────┐    │   │
│  │ │ 影響分析の精度80%以上、変更要求の完了率90%以上      │    │   │
│  │ └─────────────────────────────────────────────────────┘    │   │
│  │                                                             │   │
│  └─────────────────────────────────────────────────────────────┘   │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

タブ構成：

| タブ | 内容 |
|------|------|
| 基本情報 | target_users、experience_goals、quality_goals |
| デザイン・UX | design_system、ux_guidelines |
| 技術スタック | tech_stack_profile（フォーム形式） |
| コーディング規約 | coding_conventions（YAMLエディタ） |

### 業務領域詳細画面（/business/[bd_id]）

BD配下のBT一覧を表示し、BTの追加・編集を行う画面。

```
┌─────────────────────────────────────────────────────────────────────┐
│ ← 業務一覧    BD-BIL: 請求                                         │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  請求書の発行から入金消込までの業務を管理する領域                    │
│                                                                     │
│  ─────────────────────────────────────────────────────────────────  │
│                                                                     │
│  業務タスク一覧                    [手動で追加] [AIで追加]          │
│                                                                     │
│  ┌─────────────────────────────────────────────────────────────┐   │
│  │ BT-BIL-001: 請求書発行                                      │   │
│  │ 確定した売上データから請求書を生成する                       │   │
│  │ BR: 3件  SF: 2件                                    [詳細→] │   │
│  └─────────────────────────────────────────────────────────────┘   │
│                                                                     │
│  ┌─────────────────────────────────────────────────────────────┐   │
│  │ BT-BIL-002: 入金消込                                        │   │
│  │ 入金データと請求データを突合し、消込処理を行う               │   │
│  │ BR: 2件  SF: 1件                                    [詳細→] │   │
│  └─────────────────────────────────────────────────────────────┘   │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

操作：

| 操作 | 動作 |
|------|------|
| 手動で追加 | 空のBTフォームを開く |
| AIで追加 | AIチャットUIを開き、自然文からBT/BR/SF/SR/ACを一括生成 |
| 詳細→ | BT詳細画面に遷移 |

### 業務タスク詳細画面（/business/[bd_id]/bt/[bt_id]）

BT配下のBR一覧を表示し、BRの追加・編集、SFとのリンク管理を行う画面。

```
┌─────────────────────────────────────────────────────────────────────┐
│ ← BD-BIL    BT-BIL-001: 請求書発行                        [編集]   │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  [基本情報] [業務要件] [概念]                                       │
│  ─────────────────────────────────────────────────────────────────  │
│                                                                     │
│  業務要件一覧                            [手動で追加] [AIで追加]    │
│                                                                     │
│  ┌─────────────────────────────────────────────────────────────┐   │
│  │ BR-BIL-001: 請求書をPDFで出力できる                         │   │
│  │                                                             │   │
│  │ 実現するシステム機能:                                       │   │
│  │   SF-BIL-010: 請求書発行機能              [リンク追加]      │   │
│  │                                                     [編集]  │   │
│  └─────────────────────────────────────────────────────────────┘   │
│                                                                     │
│  ┌─────────────────────────────────────────────────────────────┐   │
│  │ BR-BIL-002: 請求書に登録番号を出力できる                    │   │
│  │                                                             │   │
│  │ 実現するシステム機能:                                       │   │
│  │   ⚠️ 未リンク                                [リンク追加]   │   │
│  │                                                     [編集]  │   │
│  └─────────────────────────────────────────────────────────────┘   │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

「実現するシステム機能」セクション：

| 操作 | 動作 |
|------|------|
| SF名クリック | SF詳細画面に遷移 |
| リンク追加 | SFを検索・選択してrealizesリンクを作成 |
| 未リンク警告 | ヘルススコア警告の対象（10.2参照） |

### システム機能詳細画面（/system/[sd_id]/sf/[sf_id]）

SF配下のSR、AC、実装単位SDを一覧表示し、編集する画面。

```
┌─────────────────────────────────────────────────────────────────────┐
│ ← SD-FI    SF-BIL-010: 請求書発行機能                     [編集]   │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  [基本情報] [システム要件] [実装単位] [リンク]                      │
│  ─────────────────────────────────────────────────────────────────  │
│                                                                     │
│  実現する業務要件:                                                  │
│    BR-BIL-001: 請求書をPDFで出力できる                              │
│                                                                     │
│  ─────────────────────────────────────────────────────────────────  │
│                                                                     │
│  システム要件一覧                                         [追加]    │
│                                                                     │
│  ┌─────────────────────────────────────────────────────────────┐   │
│  │ SR-BIL-001: 請求書PDFに登録番号を出力                       │   │
│  │ type: data_io  priority: must                               │   │
│  │                                                             │   │
│  │ 受入基準:                                                   │   │
│  │   AC-BIL-001-01: 正常系（GWT形式）                  [展開]  │   │
│  │   AC-BIL-001-02: 異常系（GWT形式）                  [展開]  │   │
│  │                                                     [編集]  │   │
│  └─────────────────────────────────────────────────────────────┘   │
│                                                                     │
│  ─────────────────────────────────────────────────────────────────  │
│                                                                     │
│  実装単位SD一覧                                           [追加]    │
│                                                                     │
│  ┌─────────────────────────────────────────────────────────────┐   │
│  │ IU-BIL-010-01: 請求書発行画面                               │   │
│  │ type: screen  entry_point: /app/billing/invoice/page.tsx    │   │
│  │                                                     [編集]  │   │
│  └─────────────────────────────────────────────────────────────┘   │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

### 変更要求詳細画面（/change-requests/[cr_id]）

CRの詳細、影響調査結果、疑義リンクを管理する画面。

```
┌─────────────────────────────────────────────────────────────────────┐
│ ← CR一覧    CR-2025-001: 請求書メール送付機能追加                   │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  status: investigating                                              │
│                                                                     │
│  [概要] [影響調査] [疑義リンク] [改修指示]                          │
│  ─────────────────────────────────────────────────────────────────  │
│                                                                     │
│  影響調査結果                                                       │
│                                                                     │
│  ┌─────────────────────────────────────────────────────────────┐   │
│  │ トップダウン分析（正本ベース）                              │   │
│  │   BR-BIL-001 → SF-BIL-010 → SR-BIL-001                      │   │
│  │                          → 実装単位SD: IU-BIL-010-01        │   │
│  └─────────────────────────────────────────────────────────────┘   │
│                                                                     │
│  ┌─────────────────────────────────────────────────────────────┐   │
│  │ ボトムアップ分析（コードベース）                            │   │
│  │   /app/billing/invoice/page.tsx                             │   │
│  │   /lib/billing/invoice-service.ts                           │   │
│  │   /lib/email/sender.ts ← 新規発見（逆流提案）               │   │
│  └─────────────────────────────────────────────────────────────┘   │
│                                                                     │
│  ─────────────────────────────────────────────────────────────────  │
│                                                                     │
│  疑義リンク: 2件（high: 1, medium: 1）                              │
│                                                                     │
│  ┌─────────────────────────────────────────────────────────────┐   │
│  │ 🔴 high: BR-BIL-001 → SF-BIL-010                            │   │
│  │    reason: SFの範囲がBRの要求を満たしていない可能性          │   │
│  │                            [確認して維持] [修正]            │   │
│  └─────────────────────────────────────────────────────────────┘   │
│                                                                     │
│  [改修指示パッケージ生成]（疑義解消後に有効化）                      │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

### AIチャット画面（/chat）

5章で設計したMastra Agentとの対話を行う画面。サイドメニューまたは各画面の「AIで追加」ボタンから起動する。

```
┌─────────────────────────────────────────────────────────────────────┐
│ AIアシスタント                                              [×]    │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  コンテキスト: BD-BIL（請求）                                       │
│                                                                     │
│  ┌─────────────────────────────────────────────────────────────┐   │
│  │ クイックアクション                                          │   │
│  │ [BT登録] [BR登録] [SF/SR/AC生成] [影響調査] [品質チェック]   │   │
│  └─────────────────────────────────────────────────────────────┘   │
│                                                                     │
│  ┌─────────────────────────────────────────────────────────────┐   │
│  │                                                             │   │
│  │ System: BD-BIL（請求）に業務タスクを追加します。             │   │
│  │         どのような業務を登録しますか？                       │   │
│  │                                                             │   │
│  │ User: 請求書を発行してメールで顧客に送る業務を追加したい     │   │
│  │                                                             │   │
│  │ Agent: BT草案を生成しました。                               │   │
│  │                                                             │   │
│  │        ┌───────────────────────────────────────────────┐    │   │
│  │        │ 📋 草案プレビュー                             │    │   │
│  │        │                                               │    │   │
│  │        │ BT-BIL-002: 請求書発行・送付                  │    │   │
│  │        │ 目的: 確定した請求データからPDFを生成し...    │    │   │
│  │        │                                               │    │   │
│  │        │ [詳細を見る]                                  │    │   │
│  │        └───────────────────────────────────────────────┘    │   │
│  │                                                             │   │
│  │        [確定] [編集] [BRも生成]                              │   │
│  │                                                             │   │
│  └─────────────────────────────────────────────────────────────┘   │
│                                                                     │
│  ┌─────────────────────────────────────────────────────────────┐   │
│  │ [メッセージを入力...]                             [送信]    │   │
│  └─────────────────────────────────────────────────────────────┘   │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

草案プレビューの操作：

| 操作 | 動作 |
|------|------|
| 詳細を見る | 草案の全フィールドをモーダルで表示 |
| 確定 | 正本に登録 |
| 編集 | マニュアル登録画面を草案データで開く |
| BRも生成 | 続けてBR草案を生成 |

### UI状態の設計

各画面は以下の状態を持ち、状態に応じた表示を行う。

| 状態 | 表示内容 | 対象画面 |
|------|---------|---------|
| ローディング | スケルトンまたはスピナー | 全画面 |
| 空状態 | 説明文と追加アクション | 一覧画面（BT/BR/SF/SR等がゼロ件） |
| エラー | エラーメッセージとリトライボタン | 全画面 |
| 認証エラー | ログイン画面へリダイレクト | 全画面 |

空状態の表示例：

| 画面 | 空状態メッセージ | アクション |
|------|-----------------|-----------|
| BT一覧 | 「業務タスクがありません」 | [手動で追加] [AIで追加] |
| 概念一覧 | 「概念が登録されていません。要件登録時にAIが提案します」 | [手動で追加] |
| 疑義リンク受信箱 | 「レビュー待ちの疑義リンクはありません」 | （なし） |

AI処理中の状態：

| 状態 | 表示内容 |
|------|---------|
| 草案生成中 | ストリーミング表示（文字が徐々に表示） |
| 影響調査中 | プログレスバーと経過時間 |
| エラー（リトライ可能） | エラー内容と[リトライ]ボタン |
| エラー（リトライ不可） | エラー内容とサポート案内 |

---

### 9.3 利用フロー

### フロー一覧

| フロー | 起点 | 想定シーン |
|--------|------|-----------|
| 初期設定 | /product-requirement | プロジェクト開始時 |
| AI登録（初期構築） | /business/[bd_id] → AIで追加 | 新規プロジェクト立ち上げ |
| 手動登録 | /business/[bd_id] → 手動で追加 | 個別の業務タスク追加 |
| 変更対応 | /change-requests | 運用中の機能追加・修正 |

### 初期設定フロー

プロジェクト開始時に行う設定。

```
1. プロジェクト作成
   /projects → [新規作成]
   
2. PR設定
   /product-requirement → 各タブを入力
   - ターゲットユーザー、体験目標、品質目標
   - 技術スタック（Next.js, Supabase, etc.）
   - コーディング規約
   
3. 業務領域の定義
   /business → [追加]
   - 業務の大分類を登録（請求、販売、在庫など）
   
4. システム領域の定義
   /system → [追加]
   - システムの大分類を登録（財務会計、販売管理など）
```

### AI登録フロー（初期構築）

AIを使って業務要件からシステム要件までを一括生成するフロー。

```
1. 業務領域詳細画面で「AIで追加」を選択
   /business/[bd_id] → [AIで追加]
   
2. AIチャットUIが起動
   - コンテキスト（現在のBD、PR）が自動注入される
   
3. 自然文で業務を説明
   「請求書を発行して顧客にメールで送る業務を追加したい」
   
4. AIが草案を生成
   - BT（業務タスク）
   - BR（業務要件）
   - SF（システム機能）+ realizesリンク
   - SR（システム要件）
   - AC（受入基準）← type別GWTテンプレートを使用
   - 概念候補
   
   ※PRのtech_stack_profileを参照し、以下に反映：
   - SRの非機能（性能/セキュリティ等）の前提
   - 実装単位SDのentry_pointの構造
   
5. 草案をレビュー
   - 各項目を確認・修正
   - 概念候補を承認/却下/保留
   
6. 確定
   - 正本に登録
```

### 手動登録フロー

AIを使わず、フォームで直接登録するフロー。

```
1. 業務領域詳細画面で「手動で追加」を選択
   /business/[bd_id] → [手動で追加]
   
2. BTフォームに入力
   - 名前、説明、業務コンテキスト、プロセスステップなど
   
3. BT詳細画面でBRを追加
   /business/[bd_id]/bt/[bt_id] → [手動で追加]
   
4. BRフォームに入力
   - 目標、制約、影響など
   
5. SFとのリンクを設定
   - 「リンク追加」で既存SFを検索・選択
   - または「新規SFを作成」でSFを作成しつつリンク
   
6. SF詳細画面でSR/AC/実装単位SDを追加
   /system/[sd_id]/sf/[sf_id] → 各セクションで追加
```

### 変更対応フロー

運用中に機能追加や仕様変更が発生した場合のフロー。4章で定義したプロセスをUIで実行する。

```
1. CR起票
   /change-requests → [起票]
   - タイトル、説明、初期スコープを入力
   
2. 影響調査開始
   /change-requests/[cr_id] → [影響調査開始]
   - トップダウン分析（正本ベース）が自動実行
   - コーディングエージェントへの調査ジョブが投入される
   
3. 調査結果の確認
   /change-requests/[cr_id] → [影響調査]タブ
   - トップダウン結果とボトムアップ結果を確認
   - 逆流提案があれば検討
   
4. 疑義リンクの解消
   /change-requests/[cr_id] → [疑義リンク]タブ
   - high/mediumを優先して処理
   - 「確認して維持」または「修正」
   
5. 改修指示パッケージ生成
   /change-requests/[cr_id] → [改修指示パッケージ生成]
   - 疑義解消後に有効化される
   - allow_paths、参照要件、残存リスクを含むパッケージを生成
   
6. 改修実行
   - コーディングエージェントが実装
   - PRが作成される
   
7. PRレビュー・マージ
   - 人間がPRをレビュー
   - マージ後、CRをcompletedに更新
```

---

### 9.4 概念候補の提案UI

BT/BR/SRの登録・編集時に、AIが本文から概念候補を抽出し、画面下部に提案セクションを表示する。

### 提案セクションの構成

```
┌─────────────────────────────────────────────────────────────────────┐
│ 概念候補                                                            │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  ┌─────────────────────────────────────────────────────────────┐   │
│  │ 「請求書」                                                  │   │
│  │ → 既存概念「請求書（Invoice）」と一致                       │   │
│  │                              [リンク] [別の概念] [却下]      │   │
│  └─────────────────────────────────────────────────────────────┘   │
│                                                                     │
│  ┌─────────────────────────────────────────────────────────────┐   │
│  │ 「登録番号」                                                │   │
│  │ → 新規概念の候補                                            │   │
│  │                              [承認] [保留] [却下]            │   │
│  └─────────────────────────────────────────────────────────────┘   │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

### 操作

| 操作 | 動作 |
|------|------|
| リンク | 既存概念にリンクし、concept_idsに自動追加 |
| 別の概念 | 別の既存概念を検索・選択 |
| 承認 | 概念辞書に新規追加し、concept_idsに自動追加 |
| 保留 | 概念一覧の「未処理」タブに表示される |
| 却下 | 今後この語句では提案しない（ブラックリスト） |

### 提案タイミング

| タイミング | 動作 |
|-----------|------|
| 新規登録時 | 保存前にリアルタイムで提案 |
| 編集時 | 変更差分に対して提案 |
| AI生成時 | 草案と同時に概念候補を抽出・提案 |

---

## 10. 非機能要件

本章では、要件管理DBアプリの非機能要件を定義する。機能要件が「何ができるか」を定義するのに対し、非機能要件は「どのような品質で動作するか」を定義する。

---

### 10.1 品質特性

### 監査性（Auditability）

要件の変更履歴を完全に記録し、「いつ、誰が、何を、なぜ変更したか」を追跡できること。

| 要件 | 実現方法 |
|------|---------|
| 変更履歴の完全記録 | 全テーブルに created_at, updated_at, updated_by を持つ |
| 変更理由の記録 | CRとの紐づけ、コミットメッセージ |
| 設計決定の記録 | 設計決定ログ（5.8参照） |
| AI判断の根拠記録 | AIが参照した要件ID、推論根拠をログに保存 |

### 参照性（Traceability）

要件間のリンクを辿り、影響範囲を追跡できること。

| 要件 | 実現方法 |
|------|---------|
| 双方向リンク | requirement_linksテーブルでsource/targetを管理 |
| リンク種別の明示 | relation_type（realizes, depends_on等） |
| リンクの健全性管理 | suspect状態、last_confirmed |
| 可視化 | グラフビュー、ツリービュー（将来拡張） |

### 同時編集対応（Concurrency）

複数人が同時に編集しても、データの整合性が保たれること。

| 要件 | 実現方法 |
|------|---------|
| 楽観的ロック | updated_atによるバージョンチェック |
| リアルタイム同期 | Supabase Realtime（将来拡張） |
| 競合検出 | 保存時に競合があれば警告 |
| 権限管理 | プロジェクト単位のRLS |

### 可用性（Availability）

システムが必要なときに利用可能であること。

| 要件 | 目標値 |
|------|--------|
| 稼働率 | 99.5%以上（月間ダウンタイム3.6時間以内） |
| 計画メンテナンス | 月1回、深夜帯に実施 |
| 障害復旧 | RTO 4時間、RPO 1時間 |

実現方法：
- Vercel/Supabaseのマネージドサービスを活用
- 日次バックアップ（Supabase自動バックアップ）
- 障害時はSupabaseのPoint-in-Time Recoveryで復旧

### 性能（Performance）

操作に対して許容できる時間内に応答すること。

| 操作 | 目標応答時間 |
|------|-------------|
| 画面表示（一覧） | 1秒以内 |
| 画面表示（詳細） | 0.5秒以内 |
| 保存操作 | 1秒以内 |
| 検索（全文検索） | 2秒以内 |
| AI草案生成 | 10秒以内（ストリーミング表示） |
| 影響調査（トップダウン） | 5秒以内 |
| 影響調査（ボトムアップ） | 30秒〜数分（ジョブ形式） |

想定データ量：
- プロジェクトあたり：BD 10件、BT 50件、BR 200件、SF 100件、SR 500件、AC 1,000件
- 概念辞書：1,000件
- 変更要求：年間100件

### 保守性（Maintainability）

システムの修正・拡張が容易であること。

| 要件 | 実現方法 |
|------|---------|
| コード品質 | TypeScript strict、ESLint/Biome |
| テスト | 単体テスト（Vitest）、E2Eテスト（Playwright） |
| ドキュメント | PRD、API仕様（OpenAPI）、コードコメント |
| デプロイ | GitHub Actions CI/CD、Vercel自動デプロイ |

---

### 10.2 ヘルススコア

ヘルススコアは「正本の品質」を可視化する仕組みである。正本のつながりが不完全だと影響分析の精度が低下するため、問題を早期に検出してダッシュボードに表示する。

### 構造的なつながりのチェック

| チェック項目 | 重要度 | 検出方法 |
|-------------|:------:|---------|
| 業務要件にシステム機能が紐づいていない | high | realizesリンクが0件 |
| システム機能に業務要件が紐づいていない | high | realizesリンクの逆引きが0件 |
| システム機能に実装単位SDが未設定 | high | 実装単位SDが0件 |
| 実装単位SDにエントリポイントがない | high | entry_pointがnullまたは空 |
| 概念辞書の用語が要件文中に出現するのにリンクがない | medium | テキストマッチ |
| 疑義リンクが一定期間放置されている | medium | suspect=trueかつlast_confirmedが30日以上前 |
| 変更要求の影響範囲と正本のつながりに矛盾がある | medium | 差分検出 |

### データ品質のチェック

| チェック項目 | 重要度 | 検出方法 |
|-------------|:------:|---------|
| プロダクト要件（PR）が未設定 | high | PRレコードが空 |
| PRのtech_stack_profileが未設定 | medium | tech_stack_profileが空 |
| 業務要件にconcept_idsがない | medium | 配列が空 |
| 業務要件にimpactsがない | medium | 配列が空 |
| システム要件にtype（観点種別）がない | high | typeがnullまたは未設定 |
| 受入基準が0件 | high | acceptance_criteriaが空 |
| 受入基準がYAML構造に準拠していない | high | lint結果 |

### ダッシュボード表示

```
┌─────────────────────────────────────────────────────────────────────┐
│ ヘルススコア                                                        │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  全体スコア: 78%                                                    │
│                                                                     │
│  ┌─────────────────────────────────────────────────────────────┐   │
│  │ 構造的なつながり                                    82%     │   │
│  │ ████████████████████░░░░                                    │   │
│  │                                                             │   │
│  │ ⚠️ 未リンクの業務要件: 5件                                  │   │
│  │ ⚠️ エントリポイント未設定: 3件                              │   │
│  └─────────────────────────────────────────────────────────────┘   │
│                                                                     │
│  ┌─────────────────────────────────────────────────────────────┐   │
│  │ データ品質                                          74%     │   │
│  │ ███████████████░░░░░                                        │   │
│  │                                                             │   │
│  │ ⚠️ 観点種別未設定のSR: 8件                                  │   │
│  │ ⚠️ 受入基準なしのSR: 2件                                    │   │
│  └─────────────────────────────────────────────────────────────┘   │
│                                                                     │
│  ┌─────────────────────────────────────────────────────────────┐   │
│  │ 疑義リンク                                                  │   │
│  │                                                             │   │
│  │ 🔴 high: 1件  🟡 medium: 3件  🔵 low: 5件                   │   │
│  │                                      [疑義リンク受信箱→]    │   │
│  └─────────────────────────────────────────────────────────────┘   │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

### 警告表示

ヘルススコアが著しく低い状態で影響分析を実行した場合、警告を表示する。

| 条件 | 警告メッセージ |
|------|---------------|
| エントリポイント登録率30%未満 | 「エントリポイントの登録が不足しています。影響分析の精度が低下する可能性があります」 |
| 観点種別未設定率50%超 | 「システム要件の観点種別が多く未設定です。適切なACが生成されない可能性があります」 |
| 未リンクBR率50%超 | 「業務要件とシステム機能のリンクが不足しています。トップダウン分析の精度が低下します」 |

### 運用上の位置づけ

ヘルススコアは「正本の信頼性」を可視化するものであり、100%を目指すものではない。

| 位置づけ | 説明 |
|---------|------|
| 目標ではない | 100%を達成することが目的ではない |
| 傾向を見る | スコアの推移で改善/悪化を把握 |
| 優先順位付け | highの問題から優先的に解消 |
| 影響分析の信頼度 | スコアが高いほど影響分析の精度が上がる |

---

### 10.3 今後の検討事項

本ツールの将来的な拡張として、以下を検討する。

### 要件管理の高度化

| 項目 | 内容 |
|------|------|
| 要件粒度の標準化 | どこまで分割するかのガイドライン |
| 依存関係の型定義拡張 | 前提、包含、排他、派生などの追加 |
| バージョン管理 | 要件のバージョニング、差分表示 |
| テンプレート機能 | 業界・ドメイン別のテンプレート |

### AI機能の拡張

| 項目 | 内容 |
|------|------|
| E2EでのCritic Loop自動化 | 登録→チェック→修正の自動化 |
| 類似要件の検出 | 既存要件との重複・類似を検出 |
| 要件の自然言語生成 | 正本からドキュメントを自動生成 |

### 外部連携

| 項目 | 内容 |
|------|------|
| IDE連携 | VSCode拡張でコードから要件を参照 |
| リポジトリ連携 | PRと要件の自動紐づけ |
| 既存システムからの移行 | コード→要件の逆生成 |
| 外部ツール連携 | Jira、Notion、Confluenceとの同期 |

### 概念辞書の高度化

| 項目 | 内容 |
|------|------|
| 統合・分割・廃止機能 | 概念のライフサイクル管理 |
| 階層構造 | 概念間の親子関係 |
| 外部辞書との連携 | 業界標準用語集との同期 |
## 11. 実装概要計画

本章では、要件管理DBアプリの実装に向けた概要計画をチェックリスト形式で示す。詳細な実装計画は別途作成する前提で、本章では実装の流れと順序を定義する。

---

### 11.1 実装方針

### フェーズ構成

実装を6つのフェーズに分け、段階的に機能を構築する。

| フェーズ | 目的 | 主な成果物 |
|---------|------|-----------|
| Phase 1 | 基盤構築（MVP） | プロジェクト設定、DBスキーマ、共通レイアウト |
| Phase 2 | 正本管理（手動） | BD/BT/BR/SD/SF/SR/AC/実装単位SDのCRUD画面 |
| Phase 3 | リンクと概念 | 要件間リンク、概念辞書、ヘルススコア |
| Phase 4 | AI機能 | Mastra Agent、チャットUI、草案生成 |
| Phase 5 | 変更管理と連携 | CR、影響調査、エクスポート、MCP Server |
| Phase 6 | 認証・セキュリティ（MVP後） | BetterAuth、RLS（プロジェクト単位アクセス制御） |

### 依存関係

```
Phase 1（基盤）
    │
    ▼
Phase 2（正本CRUD）
    │
    ├───────────────┐
    ▼               ▼
Phase 3         Phase 4
（リンク・概念）  （AI機能）
    │               │
    └───────┬───────┘
            ▼
        Phase 5
    （変更管理・連携）
            │
            ▼
        Phase 6
   （認証・セキュリティ）
```

Phase 3とPhase 4は並行して進められる。Phase 5は両方の完了後に開始する。Phase 6はMVP後の拡張として扱う。

---

### 11.2 実装チェックリスト

### Phase 1: 基盤構築（MVP）

プロジェクトのセットアップとDBの基盤を構築する。

- [ ] 1-1. Next.js 16 (App Router) プロジェクト作成
- [ ] 1-2. Tailwind CSS + shadcn/ui セットアップ
- [ ] 1-3. Supabase プロジェクト作成・接続設定
- [ ] 1-5. DBスキーマ作成（projects, product_requirements）
- [ ] 1-6. DBスキーマ作成（業務側: business_domains, business_tasks, business_requirements）
- [ ] 1-7. DBスキーマ作成（システム側: system_domains, system_functions, system_requirements, acceptance_criteria, impl_unit_sds）
- [ ] 1-8. DBスキーマ作成（concepts, requirement_links）
- [ ] 1-10. 共通レイアウト・サイドメニュー実装

### Phase 2: 正本管理（手動登録）

要件の手動CRUD機能を構築する。画面と基本的なデータ操作を実装する。

- [ ] 2-1. プロジェクト一覧・作成画面
- [ ] 2-2. プロダクト要件（PR）編集画面（基本情報タブ）
- [ ] 2-3. PR編集画面（技術スタック・コーディング規約タブ）
- [ ] 2-4. 業務領域（BD）一覧・作成・編集画面
- [ ] 2-5. 業務タスク（BT）詳細・作成・編集画面
- [ ] 2-6. 業務要件（BR）作成・編集フォーム（BT詳細画面内）
- [ ] 2-7. システム領域（SD）一覧・作成・編集画面
- [ ] 2-8. システム機能（SF）詳細・作成・編集画面
- [ ] 2-9. システム要件（SR）作成・編集フォーム（SF詳細画面内）
- [ ] 2-10. 受入基準（AC）作成・編集フォーム（SR内、GWTテンプレート対応）
- [ ] 2-11. 実装単位SD作成・編集フォーム（SF詳細画面内）
- [ ] 2-12. 設定画面（プロジェクト設定）

### Phase 3: リンクと概念

要件間のリンク管理、概念辞書、ヘルススコアを実装する。

- [ ] 3-1. requirement_links テーブル操作API
- [ ] 3-2. realizesリンク作成UI（BR詳細画面でSFを選択・リンク）
- [ ] 3-3. リンク一覧表示（SF詳細画面で「実現する業務要件」を表示）
- [ ] 3-4. 概念辞書一覧・作成・編集画面
- [ ] 3-5. 要件へのconcept_idsリンク機能
- [ ] 3-6. ヘルススコア計算ロジック（構造チェック）
- [ ] 3-7. ヘルススコア計算ロジック（データ品質チェック）
- [ ] 3-8. ヘルススコアダッシュボード表示

### Phase 4: AI機能

Mastra Agentを統合し、チャットUIと草案生成機能を実装する。

- [ ] 4-1. Mastra セットアップ・Agent定義
- [ ] 4-2. コンテキスト注入機能（PR、現在位置、既存要件）
- [ ] 4-3. bt_draft / br_draft Tool 実装
- [ ] 4-4. system_draft Tool 実装（SF/SR/AC一括生成）
- [ ] 4-5. impl_unit_draft Tool 実装
- [ ] 4-6. critic_check Tool 実装
- [ ] 4-7. AIチャットUI（/chat）実装
- [ ] 4-8. 草案プレビュー・確定フロー実装
- [ ] 4-9. 「AIで追加」ボタン連携（BD詳細→チャットUI起動）
- [ ] 4-10. 概念候補抽出・提案UI実装

### Phase 5: 変更管理と連携

変更要求、影響調査、コーディングエージェント連携を実装する。

- [ ] 5-1. DBスキーマ追加（change_requests, investigation_results）
- [ ] 5-2. 変更要求（CR）一覧・起票・編集画面
- [ ] 5-3. impact_analysis Tool 実装（トップダウン分析）
- [ ] 5-4. 疑義リンク管理（suspect状態の設定・解消UI）
- [ ] 5-5. 疑義リンク受信箱UI
- [ ] 5-6. CR詳細画面（影響調査結果表示、疑義リンク一覧）
- [ ] 5-7. エクスポート機能（7章形式のファイル出力）
- [ ] 5-8. MCP Server 実装（get_product_requirement, search_requirements等）
- [ ] 5-9. 改修指示パッケージ生成機能
- [ ] 5-10. 設計決定ログ記録機能

### Phase 6: 認証・セキュリティ（MVP後）

MVPでは実装せず、MVP通過後の拡張として実施する。

- [ ] 6-1. BetterAuth セットアップ（メール認証）
- [ ] 6-2. RLS ポリシー設定（プロジェクト単位のアクセス制御）

---

### 11.3 マイルストーン

各フェーズの完了を以下のマイルストーンで確認する。

| マイルストーン | 達成条件 | 想定期間 |
|--------------|---------|---------|
| M1: 基盤完成 | DB接続、共通レイアウトが動作 | 1週間 |
| M2: 手動登録完成 | 全要件タイプのCRUDが動作、手動でBD→BT→BR→SF→SR→AC→実装単位SDを登録できる | 2〜3週間 |
| M3: リンク・概念完成 | realizesリンク、概念辞書、ヘルススコアが動作 | 1〜2週間 |
| M4: AI機能完成 | チャットUIで草案生成→確定が動作 | 2〜3週間 |
| M5: 変更管理完成 | CR起票→影響調査→エクスポートが動作 | 2〜3週間 |
| M6: 認証・セキュリティ完成 | BetterAuthとRLSが動作 | 1〜2週間 |

想定合計: 8〜12週間 + Phase6（1〜2週間）

### 各マイルストーンの動作確認項目

M1完了時の確認項目：

| # | 確認項目 |
|---|---------|
| 1 | プロジェクト一覧が表示される |
| 2 | 新規プロジェクトを作成できる |
| 3 | サイドメニューが表示され、各画面に遷移できる |

M2完了時の確認項目：

| # | 確認項目 |
|---|---------|
| 1 | PRを編集し、保存できる（tech_stack_profile含む） |
| 2 | BD→BT→BRの階層を手動で作成・編集・削除できる |
| 3 | SD→SF→SR→AC→実装単位SDの階層を手動で作成・編集・削除できる |
| 4 | ACのGWT形式（Given-When-Then）で入力できる |
| 5 | 各画面でパンくずリストが正しく表示される |

M3完了時の確認項目：

| # | 確認項目 |
|---|---------|
| 1 | BR詳細画面からSFを検索し、realizesリンクを作成できる |
| 2 | SF詳細画面で「実現する業務要件」が表示される |
| 3 | 概念辞書を作成・編集・削除できる |
| 4 | ヘルススコアダッシュボードで警告が表示される |

M4完了時の確認項目：

| # | 確認項目 |
|---|---------|
| 1 | AIチャットUIで自然文を入力し、BT草案が生成される |
| 2 | 草案をプレビューし、確定すると正本に登録される |
| 3 | SF/SR/ACの一括生成が動作する |
| 4 | 概念候補が提案され、承認/却下/保留ができる |
| 5 | critic_checkで品質チェック結果が表示される |

M5完了時の確認項目：

| # | 確認項目 |
|---|---------|
| 1 | CRを起票し、影響調査を開始できる |
| 2 | トップダウン分析結果が表示される |
| 3 | 疑義リンクが検出され、受信箱に表示される |
| 4 | 疑義リンクを「確認して維持」「修正」できる |
| 5 | 7章形式でエクスポートし、ファイルがダウンロードできる |
| 6 | MCP ServerにAPIキーで認証してアクセスできる |

M6完了時の確認項目：

| # | 確認項目 |
|---|---------|
| 1 | ログイン・ログアウトができる |
| 2 | 認証ユーザーのみがプロジェクトにアクセスできる |
| 3 | RLSによりプロジェクト外データの参照が拒否される |

---

### 11.4 実装上の注意点

### Phase 2での注意

| 項目 | 注意点 |
|------|--------|
| フォーム設計 | 3章のYAML/Markdown形式に合わせた入力UIを用意する |
| ACのGWTテンプレート | SRのtypeに応じたテンプレートを提供し、入力を支援する |
| 画面遷移 | パンくずリストで階層を常に表示し、迷子にならないようにする |

### Phase 4での注意

| 項目 | 注意点 |
|------|--------|
| 草案の状態管理 | 未確定の草案はセッション内で保持し、画面遷移で消えないようにする |
| ストリーミング | AI生成はストリーミング表示で体感速度を改善する |
| エラーハンドリング | AI呼び出し失敗時のリトライ・フォールバックを用意する |

### Phase 5での注意

| 項目 | 注意点 |
|------|--------|
| エクスポート形式 | 7章の仕様に厳密に従い、Claude Codeが読み取れる形式を維持する |
| MCP Server | 認証（APIキー）を必須とし、不正アクセスを防ぐ |
| 影響調査の非同期実行 | コード解析は時間がかかるため、ジョブ形式で実行し進捗を表示する |

---

## Appendix A. 用語集

本PRDで使用する用語を定義する。

### 基本用語

| 用語 | 定義 |
|------|------|
| 正本 | 要件管理DBに登録され、確定した状態のデータ。草案が確定操作を経て正本になる |
| 草案 | AIが生成した未確定の要件データ。人間のレビュー・編集を経て確定すると正本になる |
| エントリポイント | コードの起点となるファイルパス。実装単位SDで定義し、影響調査の起点として使用する |

### 要件階層

| 用語 | 略称 | 定義 |
|------|:----:|------|
| プロダクト要件 | PR | プロジェクト全体の前提を定義する正本。技術スタック、品質目標等を含む |
| 業務領域 | BD | 業務の大分類。請求、販売、在庫など |
| 業務タスク | BT | 1人の担当者が一定時間で完結させる業務の単位 |
| 業務要件 | BR | 業務タスクで「達成したいこと」を記述したもの |
| システム領域 | SD | システムの大分類。財務会計、販売管理など |
| システム機能 | SF | ユーザーから見た機能の単位 |
| システム要件 | SR | システム機能に対して「何を保証すべきか」を記述したもの |
| 受入基準 | AC | システム要件の達成を検証するための具体的な条件 |
| 実装単位SD | - | システム機能を実装するための設計単位。entry_pointを持つ |

### リンクと管理

| 用語 | 定義 |
|------|------|
| realizesリンク | 業務要件（BR）をシステム機能（SF）が実現する関係を示すリンク |
| depends_onリンク | ある要件が別の要件を前提とする関係を示すリンク |
| 疑義リンク | suspect=trueの状態にあるリンク。正しさに疑義があり、レビュー待ちの状態 |
| 変更要求 | CR | 正本に対する変更の起点。機能追加、仕様変更、バグ修正等 |

### AI関連

| 用語 | 定義 |
|------|------|
| アプリ内AI | 要件管理DBアプリに組み込まれたAI（Mastra Agent）。登録支援、品質チェック等を担当 |
| コーディングエージェント | 外部で動作するAI（Claude Agent SDK）。コード解析、改修実行等を担当 |
| Tool | Mastra Agentが呼び出す機能単位。bt_draft、impact_analysis等 |
| InvestigationRequest | コーディングエージェントへの影響調査依頼 |
| InvestigationResult | コーディングエージェントからの影響調査結果 |
| ModificationPackage | コーディングエージェントへの改修指示パッケージ |

### 影響調査

| 用語 | 定義 |
|------|------|
| トップダウン分析 | 正本のリンクを辿って影響範囲を特定する分析手法 |
| ボトムアップ分析 | コード依存関係を解析して影響範囲を特定する分析手法 |
| 逆流提案 | ボトムアップ分析で発見された、正本に登録済みだが当初の影響範囲に含まれていなかった要件を提案すること |
| allow_paths | 改修を許可するファイルパスのリスト。コーディングエージェントはこの範囲内でのみ変更を行う |

### 品質管理

| 用語 | 定義 |
|------|------|
| ヘルススコア | 正本の品質を可視化する指標。構造的なつながり、データ品質をチェックする |
| 設計決定ログ | AIまたは人間が行った設計判断の記録。判断の根拠と経緯を追跡可能にする |
| GWT | Given-When-Thenの略。受入基準の記述フォーマット |
