# システム設計カードの記述品質向上（改修計画の前提整理）
最終更新: 2026-01-21

## 背景と目的
本プロダクトは、要件〜設計〜実装の情報欠落が原因で起きる「変更影響の漏れ」「設計漏れ」「誤改修」を実用上許容できる水準まで下げることを狙っている。  
システム設計カードは、その中核となる「意図の正本」であり、コーディングエージェントに正しい実装判断を伝えるための最低限の設計情報を保持する役割を持つ。

## 現状の問題（何が起きているか）
設計カードの記載が、分類（機能/データ/例外/権限/非機能）ごとに一文だけになっている。  
これにより、設計として重要な判断材料（処理の流れ、データの形、例外時の挙動、権限制約、性能条件、検証条件など）が欠落し、実装が「書いていない部分をどう解釈するか」に依存してしまう。  
結果として「意図どおりに設計が反映されない」という問題が起きやすい。

## なぜ問題になるのか（原因の構造）
コーディングエージェントは「指示された範囲のみを精度高く実装する」前提で動く。  
そのため、設計カードに書かれていない判断・制約・例外・境界条件は、実装に反映されないか、別の解釈で実装される。  
さらに、検証条件が曖昧なままだと、実装後の確認で「何を満たせば完了か」が不明確になり、品質の担保が困難になる。

## 解決の方向性（どう変えるか）
設計カードを「一文メモ」ではなく、実装判断のための最小限の設計仕様として構造化する。  
具体的には、各分類（機能/データ/例外/権限/非機能）に対して、実装に必要な判断情報を欠落なく書ける入力構造を用意し、設計の前提と検証条件を明示する。

## ユーザ視点での仕組み（設計カードの位置づけと流れ）
設計カードは「実装判断のための最小仕様」を残す場所であり、同一SRFページ内のエントリポイントカードと連携して"設計の正本"として機能する。  
※ 別途「詳細設計ドキュメント」は作成せず、必要な設計判断はすべて設計カード内で完結させる。

**ユーザがやること（流れのイメージ）**
1. **要件を選ぶ**: この設計カードが何のシステム要件に紐づくかを明示する。  
2. **目的と範囲を決める**: 何を達成する設計か、対象外は何かを短く確定する。  
3. **5分類で設計を書く**: 機能/データ/例外/権限/非機能の観点ごとに、実装判断に必要な情報を埋める。  
4. **エントリポイントは別カードで管理**: 実装起点はエントリポイントカード側に持たせ、設計カードと同一ページ内で参照関係を持つ。  
5. **受入条件を紐づける**: この設計が満たすべき条件を明記し、検証方法を残す。  

**設計カードが果たす役割**
- "何を、どう実装すべきか"の判断を固定化する  
- エントリポイントカード（どこから実装を始めるか）と連携し、設計と実装起点を紐づける  
- 受入条件と対応させることで、完了判定の根拠になる  

## 5分類と「作るもの」の関係（丁寧な説明）
ここでいう「5分類（機能/データ/例外/権限/非機能）」は**対象物の種類ではなく、設計の抜け漏れを防ぐための"観点"**である。  
一方、ユーザが実際に設計する対象は「画面」「API」「帳票」「バッジ」などの**作るもの**である。  
つまり、設計カードでは **「作るもの」ごとに「5分類の観点」で設計を書く**のが基本になる。

### 具体的な考え方
1. **まず「作るもの」を列挙する**  
   例: 画面A、API B、帳票C、バッジD
2. **各「作るもの」に対して5分類の観点で必要な情報を書く**  
   - 画面A: 機能/データ/例外/権限/非機能  
   - API B: 機能/データ/例外/権限/非機能  
   - 帳票C: 機能/データ/例外/権限/非機能  

### 例（ミニマムの書き方イメージ）
- **画面A**  
  - 機能: 入力→処理→表示の流れ、状態遷移  
  - データ: 参照/更新する項目と制約  
  - 例外: 入力不備時のメッセージ、保存失敗時の挙動  
  - 権限: 誰が見られて誰が更新できるか  
  - 非機能: 初期表示速度、一覧表示件数の上限  

- **API B**  
  - 機能: リクエスト→処理→レスポンスの仕様  
  - データ: 入出力スキーマ、保存・更新対象  
  - 例外: バリデーション、エラーコード、リトライ方針  
  - 権限: 認証/認可、アクセス範囲  
  - 非機能: レイテンシ、スループット  

### 実務の運用（現実的なルール）
すべての対象物に対して5分類すべてを"必須"にすると負荷が大きい。  
そこで **「対象物 × 観点」のマトリクスを用意し、重要な観点だけ必須化する**のが現実的。

要点は「作るものの行を増やすだけだと観点漏れが起きる」ので、  
**各作成対象に"観点の枠"を付けて書くことが、浅い設計の防止策になる**という考え方である。

## 画面イメージ（テキストワイヤー）
以下は、ユーザが「作るものを選び、その対象ごとに5分類で埋める」流れが分かるようにした簡易ワイヤーである。

```
+----------------------------------------------------------------------------------+
| システム設計カード                                                               |
| 要件: [SRF-001]  目的: [                     ]  範囲: [             ]           |
| 対象外: [                               ]                                         |
+--------------------------- 作るもの（対象の一覧） -------------------------------+
| [ ] 画面A   [ ] API B   [ ] 帳票C   [ ] バッジD                                    |
+----------------------------------------------------------------------------------+
| 対象: 画面A                                                                       |
|                                                                                  |
| 機能    : [入力] [処理] [出力] [副作用]                                           |
| データ  : [参照/更新項目] [制約/整合性]                                           |
| 例外    : [エラーケース] [ユーザー通知] [ログ]                                   |
| 権限    : [役割] [操作可否] [境界]                                               |
| 非機能  : [性能] [可用性] [監視]                                                 |
|                                                                                  |
| 受入条件: [条件] [検証方法(自動/手動)]                                            |
+----------------------------------------------------------------------------------+
```

### システム側で固定する必須観点マトリクス（案）
必須/任意の指定は**ユーザが選ぶのではなく、システム側で固定する**。  
これにより「誰が指定するか」の属人化を排除する。

| 対象物タイプ | 機能 | データ | 例外 | 権限 | 非機能 | 補足 |
|--------------|------|--------|------|------|--------|------|
| 画面 | 必須 | 必須 | 必須 | 必須 | 任意 | 画面は権限と例外が重要。非機能は必要時のみ。 |
| API | 必須 | 必須 | 必須 | 必須 | 必須 | 外部影響が大きいため全観点必須。 |
| 帳票 | 必須 | 必須 | 必須 | 任意 | 必須 | 権限は参照権限がある場合のみ必須。 |
| バッジ | 必須 | 任意 | 必須 | 必須 | 任意 | 軽量UI要素のためデータ/非機能は状況次第。 |

## データモデルと保存方式（実装方針）
5分類の各観点に「小項目」（入力/処理/出力など）があるが、これをどう保存するかが設計上の重要な判断点となる。

### 既存テーブルとの関係

現在の `system_functions` テーブルには以下のカラムが既に存在する:
- `system_design: jsonb` — 設計項目配列（現状: `[{category, title, content}]`）
- `entry_points: jsonb` — エントリポイント配列

また、`system_requirements` テーブルには:
- `category: text` — 観点種別（function/data/exception/auth/non_functional）

**→ 新テーブル追加ではなく、既存の `system_design` カラムの構造を拡張する方針を採用**

### 方式の比較と採用方針

| 方式 | メリット | デメリット |
|------|----------|------------|
| **カラム方式**（小項目ごとに独立カラム） | 入力強制、検索容易 | スキーマが複雑化、対象物タイプ別の差異に対応困難 |
| **Markdown方式**（自由記述） | 柔軟、スキーマ変更不要 | 制約かけにくい、浅い記述を防げない |
| **JSONB方式**（既存カラム内で構造化） | スキーマ安定＋構造化可能＋バリデーション可能 | JSONスキーマの管理が必要 |

**→ 採用方針: 既存 `system_design` カラムのJSONB構造を拡張**

### 拡張後の system_design 構造

**現状（一文メモ）:**
```json
[
  { "category": "function", "title": "機能設計", "content": "一文だけの説明..." }
]
```

**拡張後（構造化）:**
```json
[
  {
    "category": "function",
    "title": "機能設計",
    "content": {
      "input": "ユーザーが入力する項目と形式",
      "process": "処理の流れ（前提条件→本処理→事後条件）",
      "output": "画面表示/レスポンスの内容",
      "sideEffects": "保存、通知、外部連携などの副作用"
    }
  }
]
```

### 各分類の content スキーマ

**機能設計（function）**
```json
{
  "input": "ユーザーが入力する項目と形式",
  "process": "処理の流れ（前提条件→本処理→事後条件）",
  "output": "画面表示/レスポンスの内容",
  "sideEffects": "保存、通知、外部連携などの副作用"
}
```

**データ設計（data）**
```json
{
  "tables": ["対象テーブル名"],
  "fields": "参照/更新する項目",
  "constraints": "制約（必須、ユニーク、参照整合性）",
  "migration": "スキーマ変更が必要な場合の方針"
}
```

**例外設計（exception）**
```json
{
  "errorCases": "代表的なエラーケース",
  "userNotification": "ユーザーへの通知方法",
  "logging": "ログ出力方針",
  "recovery": "リトライ/復旧方針"
}
```

**権限設計（auth）** ※DBでは `auth` だが概念上は「権限」
```json
{
  "roles": ["対象ロール"],
  "operations": "許可される操作",
  "boundary": "参照/更新の境界"
}
```

**非機能設計（non_functional）**
```json
{
  "performance": "応答時間、スループット",
  "availability": "可用性要件",
  "monitoring": "監視、監査ログ要件"
}
```

### 必須キーの定義

各分類で「これがないと実装判断できない」キーを必須とする。  
入力負荷を抑えるため最小限に絞り、残りは任意とする。

| 分類 | 必須キー | 任意キー | 判断理由 |
|------|----------|----------|----------|
| **機能（function）** | input, process, output | sideEffects | 入出力と処理がないと実装不可 |
| **データ（data）** | fields | tables, constraints, migration | 対象項目は必須、制約は後から追加可 |
| **例外（exception）** | errorCases | userNotification, logging, recovery | エラーケースがないと例外設計にならない |
| **権限（auth）** | roles, operations | boundary | 誰が何をできるかが最低限必要 |
| **非機能（non_functional）** | (なし) | performance, availability, monitoring | 要件によって必要な観点が異なる |

※ 非機能は「1つ以上の入力を推奨」とし、完全な空は警告表示。

### 入力UIの構造

**方針: スキーマ駆動 + 分類別コンポーネントのハイブリッド**

| 層 | 役割 | 実装 |
|----|------|------|
| **スキーマ層** | 型定義・バリデーション | Zodスキーマ（`lib/domain/schemas/`） |
| **UI層** | 分類ごとのフォーム | 分類別コンポーネント（`components/forms/design/`） |
| **プリミティブ層** | 共通入力部品 | TextArea, ArrayInput, OptionalField など |

**UI構造イメージ:**
```
SystemDesignEditor
├── CategoryTabs（タブ切替: 機能/データ/例外/権限/非機能）
│   ├── FunctionDesignForm（機能設計フォーム）
│   │   ├── RequiredTextArea（入力 *必須）
│   │   ├── RequiredTextArea（処理 *必須）
│   │   ├── RequiredTextArea（出力 *必須）
│   │   └── OptionalTextArea（副作用）
│   ├── DataDesignForm（データ設計フォーム）
│   │   ├── RequiredTextArea（対象項目 *必須）
│   │   ├── OptionalArrayInput（対象テーブル）
│   │   ├── OptionalTextArea（制約）
│   │   └── OptionalTextArea（マイグレーション方針）
│   └── ... 他の分類も同様
└── ValidationSummary（未入力・曖昧語の警告表示）
```

**採用理由:**
1. **Zodスキーマ**: 型安全・バリデーション統一・サーバー/クライアント共用
2. **分類別コンポーネント**: UXを分類ごとに最適化できる（完全自動生成だと融通が利かない）
3. **プリミティブ共通化**: 重複コード削減、スタイル統一

### JSONスキーマの管理方針

**→ アプリ内でZodスキーマとしてハードコーディング**

理由:
1. スキーマ変更頻度は低い（設計観点が大幅に変わることは稀）
2. Gitでバージョン管理できる（変更履歴の追跡が容易）
3. DBにスキーマを持つと複雑化する割にメリット少ない
4. 型安全（TypeScript連携でコンパイル時チェック可能）

配置場所: `lib/domain/schemas/system-design.ts`

```typescript
// Zodスキーマ定義
import { z } from "zod";

export const functionDesignSchema = z.object({
  input: z.string().min(1, "入力は必須です"),
  process: z.string().min(1, "処理は必須です"),
  output: z.string().min(1, "出力は必須です"),
  sideEffects: z.string().optional(),
});

export const dataDesignSchema = z.object({
  fields: z.string().min(1, "対象項目は必須です"),
  tables: z.array(z.string()).optional(),
  constraints: z.string().optional(),
  migration: z.string().optional(),
});

export const exceptionDesignSchema = z.object({
  errorCases: z.string().min(1, "エラーケースは必須です"),
  userNotification: z.string().optional(),
  logging: z.string().optional(),
  recovery: z.string().optional(),
});

export const authDesignSchema = z.object({
  roles: z.array(z.string()).min(1, "対象ロールは必須です"),
  operations: z.string().min(1, "許可される操作は必須です"),
  boundary: z.string().optional(),
});

export const nonFunctionalDesignSchema = z.object({
  performance: z.string().optional(),
  availability: z.string().optional(),
  monitoring: z.string().optional(),
}).refine(
  (data) => Object.values(data).some((v) => v && v.length > 0),
  { message: "非機能設計は1つ以上の項目を入力してください" }
);
```

### バリデーション方針
- **アプリ層**: Zodスキーマで各分類のJSON構造をバリデーション
- **必須キーの強制**: 分類ごとに必須キーを定義（上記スキーマ参照）
- **曖昧語lint**: 「高速」「柔軟」などの曖昧語を検出して警告（UI側で実装）
- **マイグレーション**: 既存の一文データは `content: { legacy: "既存の一文" }` として保持し、段階移行

## 設計カードに最低限書くべき内容
以下は「実装を安定化させるために欠かせない設計情報」の最小セットである。  
※ 先述の「5分類」と対応関係を明確にするため、分類を明示する。  
※ 上記JSONB方式に基づき、各分類の中身は構造化されたキーで入力する。

### 1) 目的・範囲・対象外（共通の前提）
- 何を実現する設計か（目的）
- どこまでが対象で、どこは対象外か（誤改修防止）

### 2) エントリポイントとの連携（共通の前提）
- エントリポイントは別カードで管理（同一SRFページ内）
- 設計カードからは「どのエントリポイントがこの設計に対応するか」を意識して書く

### 3) 機能設計 ← 5分類の「機能」に対応
- 入力 → 処理 → 出力の流れ
- 前提条件/事後条件
- 状態遷移や副作用（保存、通知、外部連携など）

### 4) データ設計 ← 5分類の「データ」に対応
- 対象データの構造（テーブル/項目/型）
- 制約（必須、ユニーク、参照整合性）
- 変更が必要なスキーマ/マイグレーション方針

### 5) 例外設計 ← 5分類の「例外」に対応
- 代表的なエラーケース
- 例外時の挙動（リトライ、ユーザー通知、ログ）

### 6) 権限設計 ← 5分類の「権限」に対応
- 役割と操作の対応関係
- 参照/更新の境界

### 7) 非機能設計 ← 5分類の「非機能」に対応
- 性能/可用性/監視に関する条件
- 例: 応答時間、同時実行数、監査ログの要件

### 8) 受入条件・検証方法（共通の完了基準）
- 「満たせば完了」と言える条件を定量または二値で記述
- どの方法で検証するか（自動/手動）

### 9) 設計判断の理由（共通のトレーサビリティ）
- なぜこの方式を選んだか
- 他案を採用しなかった理由（後からのブレ防止）

## 入力項目の工夫（記述を深くするためのUX）
浅い一文を防ぐために、自由記述に頼らない構造化入力が有効。

- 分類ごとに「必須の小項目」を設ける  
  例: 機能設計は「入力/処理/出力/副作用」を必須化する
- 曖昧語のlint（例: 高速、柔軟、便利）で警告を出す
- 受入条件と設計を紐づける入力を用意する
- 依存・影響先の入力欄を設け、波及漏れを防ぐ

## 期待される効果
設計カードが「実装の前提資料」として機能し、  
コーディングエージェントが解釈に迷わず実装できる。  
また、受入条件と設計が結びつくことで、完了判定が明確になる。

## 改修計画の論点（決めるべき事項）
ここは「実装タスクに落とし込む前に合意すべき決定事項」を列挙したもの。  
単なるメモではなく、後でチェックリスト化するための論点の棚卸しである。

### 確定事項
- **保存方式**: 既存 `system_functions.system_design` カラムの content を構造化
- **スキーマ管理**: Zodスキーマとしてアプリ内にハードコーディング（`lib/domain/schemas/`）
- **テーブル変更**: 不要（既存JSONBカラムの中身を拡張するのみ）
- **入力UI**: スキーマ駆動 + 分類別コンポーネントのハイブリッド方式
- **必須キーの定義**: 上記「必須キーの定義」セクション参照

### 未確定・要検討事項
- 曖昧語lint: 検出対象ワードリストの確定
- マイグレーション: 既存一文データの扱い（`{ legacy: "..." }` で保持 or 手動移行）
- 「作るもの」の扱い: 現状system_designは「作るもの」単位ではなく分類単位。要件に応じて構造変更が必要か検討
