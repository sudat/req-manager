# Phase 7: 運用ガードレール（lint/互換収束）チェックリスト

## 作業概要
Phase 1-6で「登録→編集→詳細表示→ヘルススコア」が一通り動く状態になった。
Phase 7では、正本の信頼性を落としやすいポイントに対して「警告（lint）」「可視化（ヘルススコア）」「互換の収束方針」を整備し、運用で積み残しが放置されない仕組みにする。

- KISS: ブロックはせず警告中心で、まず運用に載る最小単位で整備する
- DRY: lint結果はスコア/一覧/詳細/フォームで再利用できる形にする
- YAGNI: legacy列の削除は急がず、収束条件を満たしたら段階的に進める

難易度（Phase 7を実装まで行う場合）: ★★☆
根拠: 5-10 files, ~200-400 lines, 2-4 components
リスク: lintの誤検知/過検知、UI表示追加によるUX変化、互換収束の手順ミスによる既存データ破綻

前提:
- [x] [Phase 1: DBテーブル修正（Supabase）](2026-01-19-prd-v1-3-phase1-db-schema.md) が完了している
- [x] [Phase 2: データアクセス層修正（lib/data/*）](2026-01-19-prd-v1-3-phase2-data-layer.md) が完了している
- [x] [Phase 3: 画面修正（フォーム・詳細表示）](2026-01-19-prd-v1-3-phase3-ui-forms.md) が完了している
- [x] [Phase 4: ヘルススコア（品質監視）](2026-01-19-prd-v1-3-phase4-health-score.md) が完了している
- [x] [Phase 5: 既存データ移行・seed整備](2026-01-19-prd-v1-3-phase5-seed-mock-data.md) が完了している
- [x] [Phase 6: 動作確認（E2E優先）](2026-01-19-prd-v1-3-phase6-e2e.md) が完了している

- 戻り先: [概要計画（高レベル）](2026-01-19-prd-v1-3-schema-health-score.md)

---

## 0. 現状確認（Phase 7の前提を確定）
- [x] ヘルススコアに「受入条件 lint 警告」が存在する（例: `lib/health-score/index.ts` の `acceptance_criteria_lint_warning`）
- [x] UIでヘルススコアの検出ルール（issues）が表示される（例: `components/health-score/health-score-card.tsx`）
- [ ] 「lintをどこで見せるのが運用上最適か」を決める
  - [ ] 例: (A) ヘルススコアのみ / (B) 詳細画面の受入条件表示にも / (C) 編集フォームでリアルタイムに
  - [ ] 方針: KISSで (B) まで、(C) は必要になったら

---

## 1. 受入条件 lint（警告表示の整備）
現状はヘルススコア側で「曖昧語の簡易lint」を行っている（最小）。
Phase 7では、運用で“直せる”ように警告の見せ方と再利用構造を整える。

- [ ] lintの責務分離（DRY）
  - [ ] lintロジックを `lib/health-score/*` から切り出し、UIと共通利用できる場所へ移動する
  - [ ] lint結果の型（例: `warnings: { code, message, severity }[]`）を定義する
- [ ] 受入条件表示で lint 警告を表示する（KISS: 警告のみ・保存ブロックなし）
  - [ ] 詳細表示（業務要件/システム要件）で、該当する受入条件行に「lint警告」バッジを表示する
  - [ ] 編集フォームで、該当する入力行に補助テキストを表示する（任意）
- [ ] lint基準をPRDの表現に近づける（YAGNI: 過剰な自然言語解析はしない）
  - [ ] 現状の「曖昧語辞書」＋「数値/閾値の欠如」など、軽量なヒューリスティクスを追加するか判断する
  - [ ] ルール追加時は誤検知が運用負債になるため、段階導入（feature flag不要なら設定/定数で十分）

---

## 2. ヘルススコアへのlint反映（重複計算を解消）
- [x] ヘルススコアに lint 警告が反映されている（issue: `acceptance_criteria_lint_warning`）
- [ ] lint責務分離後、ヘルススコアが共通lint結果を利用する（DRY）
  - [ ] 「どの単位でカウントするか」を明文化する（要件単位/受入条件単位）
  - [ ] UI表示の説明文（ラベル）を運用者が理解できる文言にする

---

## 3. 互換列の収束方針（`acceptance_criteria` / `code_refs`）
現状は互換のため二重の表現が存在する（新: `acceptance_criteria_json` / `entry_points`、旧: `acceptance_criteria(text[])` / `code_refs`）。
収束方針が無いと二重書きが恒久化し、保守コストとバグ温床になるため、方針だけは先に決める。

### 3.1 収束対象と現状の扱い整理
- [ ] 収束対象を明文化する
  - [ ] 業務要件/システム要件: `acceptance_criteria_json` を正、`acceptance_criteria(text[])` を旧として段階廃止
  - [ ] システム機能: `entry_points` を正、`code_refs` を旧として段階廃止
- [ ] 現状の読み取り・書き込み方針を明文化する（どちらを優先し、どう同期するか）

### 3.2 収束の完了条件（いつ二重書きをやめるか）
- [ ] 完了条件を定義する（例）
  - [ ] 全レコードが新カラムを持つ（新カラムが空の場合の扱いも含む）
  - [ ] アプリの読み取りが新カラムのみで成立する（fallback無しでE2Eが通る）
  - [ ] 運用上、旧カラム参照が不要と判断できる（監視/移行期間の合意）
- [ ] ロールバック条件を定義する（問題が起きたらどこまで戻すか）

### 3.3 段階導入ステップ（推奨）
- [ ] Step 1: 可視化（KISS）
  - [ ] 「旧カラム由来で表示されている」レコードを検知できるようにする（ヘルススコア or 警告）
- [ ] Step 2: バックフィル（必要な範囲だけ）
  - [ ] 旧→新の変換を一括実行する手順（SQL/RPC/スクリプト）を確定する
  - [ ] 実行前後で件数が一致することを確認する
- [ ] Step 3: 読み取りの単一化
  - [ ] アプリが新カラムのみを正として扱い、旧カラムは参照しないようにする
- [ ] Step 4: 二重書きの終了（YAGNI: 直ちに削除しない）
  - [ ] 書き込みで旧カラムを更新しない（必要なら移行期間を設ける）
- [ ] Step 5: DBスキーマの整理（将来）
  - [ ] 旧カラムのdrop/権限制御/ビュー化など、最終形を決める

---

## 4. 検証（回帰）
- [ ] Phase 6の主要シナリオ（CRUD/互換/ヘルススコア）を再実行し、警告追加が破綻を生まないことを確認する
- [ ] lint警告が出る/出ない例を用意し、UIで判別できることを確認する

---

## 完了基準（Phase 7）
- [ ] lint警告の「見る場所」と「直し方」が運用上明確である
- [ ] lint結果がヘルススコアに反映され、重複計算がない（または許容理由が明文化されている）
- [ ] legacy列の収束方針（完了条件/段階導入/ロールバック）が文章化されている
