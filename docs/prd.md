# LLM支援型要件管理ツール 要件定義書 v1.3

- 最終更新: 2026-01-17

## 1. 目的と設計思想

### 1.1 解決する課題（本質）

本プロダクトの目的は、コーディングエージェントを前提とした大規模システム開発において、要件〜設計〜実装の情報が分断・欠落することで発生する「変更影響の漏れ」「設計漏れ」「誤改修」を実用上許容できる水準まで低減し、個人〜少人数でも開発を完遂可能にするための“正本（Single Source of Truth）”を提供することである。

本ツールが対象とするのは、ERP級（複数業務領域・多数モジュール・法対応/例外・外部連携が多い）で、変更要求が連鎖しやすいシステムである。
一方で開発体制は、コーディングエージェントの活用により「個人〜少人数でも完遂できる」ことを前提とする。
狙いは、ERP級案件としての売上規模は維持しつつ、開発メンバ削減によって開発コストを圧縮し、差分として利益を最大化できる状態を作ることにある。

従来のExcel/ドキュメント中心運用では、人間が体系全体を頭で保持し続ける必要があり、規模の増大とともに以下が致命傷になる。
- 断片的なヒアリングから要件を体系化する際の穴埋め（追加質問・提案・整合）
- 要件と設計・実装の参照関係（トレーサビリティ）の維持
- 仕様変更時の影響範囲特定（特に実装ファイル単位の漏れ）

一方で、LLMに全自動で判断を委ねると文脈誤解により誤候補が混ざりやすく、結果としてコーディングエージェントの誤改修・改修漏れを誘発する。
よって本ツールは「AIが候補生成と根拠整形を行い、人間が確定する」分業により、漏れ最小化と運用継続性を両立する。

#### 1.1.1 成功状態

成功状態はコーディングエージェント主体での変更要求の適用後も、ユーザー（業務側）がやりたいこと・やりたかったことがシステムとして満たされ続けることである。

その成功状態を実現するための条件を本PRDでは「受入条件」とし、業務要件・業務フロー（ユーザーの意図）が満たされているかを判定するための、検証可能な条件（チェック可能な表現）と定める。言い換えると「これが満たされないなら受入NG」と判断できる基準の集合である。

#### 受入条件の粒度

受入条件は粒度を分けて保持する。
- 業務受入条件: 業務タスク単位で、業務側の期待状態（やりたいこと）を検証可能に書いた条件
- システム受入条件: システム要件単位で、機能＋データ＋例外＋権限＋非機能が業務受入条件を満たすために必要な条件

#### 受入条件の検証可能性（lint基準）

受入条件は「検証可能に書かれている」ことが必須である。本ツールは以下の基準でlintを行い、曖昧な受入条件を警告する。

| 基準 | 説明 | NG例 | OK例 |
|------|------|------|------|
| 主語・目的語・動詞が明確 | 誰が何をどうするかが特定できる | 「使いやすいこと」 | 「経理担当者が請求書PDFをダウンロードできること」 |
| 定量的または二値で判定可能 | 数値基準があるか、Yes/Noで判定できる | 「高速であること」 | 「応答時間が3秒以内であること」 |
| 判定者によって結果が変わらない | 客観的に判定できる | 「見やすいレイアウトであること」 | 「登録番号が帳票右上に印字されていること」 |

lintは警告のみとし、ブロックはしない。ただし、曖昧な受入条件が残っている場合、確認結果の信頼性が低下するため、ヘルススコア（2.8.1）に反映する。

#### 受入条件の確認状態（本ツールが追跡する範囲）

受入条件は「検証可能に書かれている」だけでは不十分であり、「実際に検証されたか」を追跡しなければ成功状態は判定できない。
本ツールはテスト管理ツールではないが、受入条件ごとに以下を保持する。

| 属性 | 説明 |
|------|------|
| 確認状態 | 未確認 / 確認済み(OK) / 確認済み(NG) |
| 検証手段 | どのように確認するか（人間目視 / 自動テスト / 外部ツール参照 等） |
| 確認者 | 誰が確認したか（MVP段階では入力者名で可） |
| 確認日時 | いつ確認したか |
| 確認根拠 | 何をもってOK/NGと判断したか（スクリーンショット、テスト結果リンク、目視確認メモ等） |

検証手段は受入条件の性質によって異なる。
- 人間目視：画面表示、帳票出力、操作フローなど、人間が見て判断するもの
- 自動テスト：単体テスト、E2Eテストなど、コードで検証できるもの（テスト結果へのリンクを根拠とする）
- 外部ツール参照：外部のテスト管理ツールやCI結果へのリンクで確認するもの

本ツールはテストケースの詳細設計や実行管理は行わないが、「この受入条件は確認されたか」の状態は追跡する。
これにより、テスト管理ツールとの責務境界は以下となる。

| 責務 | 本ツール | テスト管理ツール（外部） |
|------|----------|------------------------|
| 受入条件の定義 | ○ | - |
| 検証手段の指定 | ○ | - |
| 確認状態の追跡 | ○ | - |
| テストケースの詳細設計 | - | ○ |
| テスト実行・結果管理 | - | ○ |
| テスト結果と受入条件の紐づけ | リンク参照 | 実体管理 |

#### 北極星KPIの定義

「満たす」とは、変更要求の適用後に次が同時に成立することを指す。
- 影響範囲に紐づくすべての受入条件が「確認済み(OK)」である

変更適用前の状態に関わらず、影響範囲に含まれる要件の受入条件は再確認が必要となる。「未確認」の受入条件が残っている状態は判定不能であり、「確認済み(NG)」が1件でもあれば不合格である。

- 北極星KPI（結果）: 変更要求適用後、影響範囲に紐づく受入条件がすべて「確認済み(OK)」であること
- 先行KPI（品質）:
  - 影響範囲の漏れ率（特に設計/ファイルレベル）を最小化（Recall最優先）
  - 影響範囲の確信度・根拠の提示品質（レビューで確定できる状態）
  - 受入条件の確認率（未確認のまま放置されていないか）
  - 受入条件の検証可能性（lint警告の件数）

### 1.1.2 コーディングエージェントの能力仮定と本ツールの役割

本ツールは、コーディングエージェント（Claude Code等）を「指示された範囲を高精度に実装するプログラマー」と位置づける。
具体的には、以下の能力仮定を置く。

#### コーディングエージェントができること
- 明示された変更対象ファイルに対して、指示どおりの変更を高精度に実装する
- 指示に含まれる受入条件を満たすようにコードを修正する
- 指示された範囲内での整合性（型、API契約、テスト）を維持する

#### コーディングエージェントが自発的にはやらないこと
- 指示範囲外への波及影響の検出と対処
- 変更対象として明示されていないファイルの修正
- 業務要件や設計意図を踏まえた「本来直すべき範囲」の判断

なお、コーディングエージェントが実装したコードにバグが含まれる可能性はある。バグの検出は受入条件の確認フェーズで担保し、本ツールの責務はあくまで「影響範囲の漏れを防ぐこと」に限定する。

例：A画面→B(DB)→C画面の依存関係があるシステムで、A画面の仕様変更を指示した場合
- コーディングエージェントはA画面とBのスキーマ変更を精緻に実装する
- しかしB→C間の整合性（Cが参照するBのフィールド変更等）は、指示に含まれていなければ考慮しない
- 結果として、C画面で実行時エラーや表示崩れが発生する

この「波及影響の見落とし」こそが、本ツールが解決すべき中核課題である。

#### 本ツール（アプリ内AI）の責務
本ツールは、コーディングエージェントの「視野の狭さ」を補完するために、以下を担う。

1. 影響範囲の網羅的検出
   - 変更要求に対して、A-B-Cの関係性を踏まえた影響範囲を提案する
   - 人間が見落としやすい間接的な依存（B経由でCに波及）も検出する

2. 変更計画の策定
   - 影響範囲に基づき、「何を」「どの順序で」「どう直すか」の計画を生成する
   - 各変更の根拠（なぜこのファイルを直す必要があるか）を明示する

3. 実装指示パッケージの生成
   - コーディングエージェントが「指示された範囲を直せば全体整合が取れる」状態になるよう、指示を構成する
   - 指示には変更対象だけでなく、「変更してはいけない制約」「確認すべき受入条件」を含める

#### コーディングエージェントへの指示品質が成否を分ける
本ツールの価値は、コーディングエージェントに渡す指示の品質に集約される。
指示が不完全であれば、コーディングエージェントがいかに優秀でも波及影響は漏れる。

したがって、実装指示パッケージには以下を必須とする。
- 変更対象ファイルの完全なリスト（漏れがあればそのファイルは直されない）
- 各ファイルの変更意図（何を達成するための変更か）
- 影響を受ける他ファイルとの整合性制約（「このファイルを直すなら、あのファイルのこの部分も確認せよ」）
- 受入条件（業務/システム）と、どのファイルがどの受入条件に対応するか

#### 典型的な失敗の瞬間（本ツールが防ぐこと）

例：法対応（インボイス対応）として「請求書PDFに登録番号/税率別合計を追加する」変更要求が入る。

- コンサルはA:帳票テンプレート、B:請求ヘッダのDB/APIを中心に改修指示を作り、コーディングエージェントへ渡す
- コーディングエージェントは指示どおりA/Bを高精度に実装し、見える範囲のテストも通る
- しかし実際には、C:会計仕訳作成、D:外部連携CSV/EDI、E:監査ログ/帳票保全などへ波及しており、指示に含まれないC/D/Eは改修されない
- 本番の月次締め/監査対応のタイミングで「誤仕訳・突合不一致・出力不整合」が発覚し、緊急改修・手戻り・信頼毀損が発生する

破綻点は「影響範囲（特にファイル/バッチ/外部I/F）の漏れ」と、「業務受入条件が“帳票が出る”に偏り、下流（会計/監査/連携）の受入観点が抜ける」ことにある。


### 1.2 2つの管理対象（ベースライン仕様と変更要求）

本ツールは「ベースライン仕様（状態）」と「変更要求（イベント）」を分離して管理する。目的は、日常の“仕様照会”と、変更時の“影響分析〜反映”を混同しないことである。

| 区分 | ベースライン仕様 | 変更要求 |
|------|------------------|----------|
| 性質 | 状態（現行仕様の体系） | イベント（仕様変更の単位） |
| 代表的な問い | 「請求業務の仕様は？」 | 「インボイス対応で何を変える？」 |
| 主な構造 | 業務（分類）→業務タスク→業務要件→システム要件（↔ システム領域/機能） | 変更要求→影響範囲→変更内容→適用（版/コミット） |
| ゴール | 正本として参照できる体系 | 漏れのない影響分析と、受入条件を満たす変更の完遂 |

### 1.2.1 正本（Single Source of Truth）とコーディングエージェントのガードレール

本ツールは、要件・設計・受入条件・根拠・決定履歴からなる「意図の正本（Single Source of Truth）」である。
一方、実装（コード/設定/DBマイグレーション等）はリポジトリに存在する「現実の正本」である。
本ツールは現実の正本を取り込んで置き換えるのではなく、参照（リンク/パス/コミット）と根拠を保持し、「意図↔現実」の対応関係を維持する。ズレが疑われる箇所はsuspect linkとして可視化し、変更要求として収束させる。

特に変更要求フェーズでは、コーディングエージェントの「指示範囲外は見ない」特性を前提に、以下を必ず保持する。

- 影響範囲（変更対象の完全なリスト）
  - 業務要件・システム要件・システム機能・設計成果物・画面/遷移/UX仕様・ファイルを含む
  - コーディングエージェントはファイルリストに含まれないファイルを自発的に修正しない
  - 漏れは即座に波及影響の見落としにつながる
- 変更内容案（各ファイルで何をどう変えるか）
  - 変更の意図と、他ファイルとの整合性制約を含める
- 受入条件（何を満たせば完了か）
  - 変更対象ファイルと受入条件の対応関係を明示する
  - コーディングエージェントが「このファイルの変更でこの受入条件が満たされる」と認識できる状態にする
- 根拠（なぜその要件/ファイルが影響範囲に含まれるか）
  - 人間のレビュー用であると同時に、コーディングエージェントへの文脈提供にもなる

### 1.2.2 管理対象の範囲（正本として保持するもの／保持しないもの）

本ツールは「意図の正本」を保持し、「現実の正本（リポジトリ）」は参照に留める。正本の維持コストを最小化するため、保持範囲を以下のように定める。

#### Must（正本として保持）

| 対象 | 理由 |
|------|------|
| 業務要件（業務タスク単位、受入条件を含む） | コードに書いてない。業務側の意図 |
| システム要件（機能＋データ＋例外＋権限＋非機能、受入条件を含む） | 「なぜこう作ったか」はコードから読めない |
| 設計成果物（設計書）の要約・意図 | 設計判断の理由はコードに残らない |
| 概念辞書（用語・同義語・影響領域） | 業務用語とシステム用語の対応はコードにない |
| システム領域（モジュール）/ システム機能（機能カタログ） | 影響分析の観点軸 |
| エントリポイント（システム機能ごとの実装起点） | コード依存展開の入口 |
| 変更要求ごとの確定データ（影響範囲・変更内容・受入条件・根拠） | 正解データとして蓄積 |

#### Want（任意・段階導入）

| 対象 | 理由 |
|------|------|
| 画面/遷移/UX仕様 | 影響分析の精度向上に寄与 |
| 設計書の詳細本文 | 根拠提示の充実 |

#### 保持しない（コード解析で取得）

| 対象 | 理由 |
|------|------|
| ファイル間の依存関係（A imports B） | コード解析でオンデマンドに取れる。維持コストが高く陳腐化しやすい |
| コード本文 | リポジトリが正本 |
| 詳細な実装仕様 | コードを読めばわかる |

#### エントリポイントの定義

エントリポイントは「このシステム機能を触るならまずここを見ろ」という実装の起点。ディレクトリでもファイルでもよい。

| 例 | 粒度 |
|----|------|
| `/app/billing/invoice/` | ディレクトリ |
| `InvoicePdfGenerator.ts` | ファイル |
| `/app/billing/invoice/InvoicePdfGenerator.ts` | フルパス |

エントリポイントからの依存展開はコーディングエージェント（Claude Code）に委譲する。本ツールの責務は「エントリポイントまで辿り着くこと」。

### 1.3 概念辞書は「育てる」

概念辞書（用語、同義語、影響システム領域、必読ドキュメント）は、初期に人間が作り込む前提を置かない。
要件入力や変更要求分析のたびにAIが概念候補を抽出し、人間が承認・修正・却下することで、副産物として辞書を育てる。

運用中の重複・衝突・陳腐化に対応するため、概念の統合・分割・廃止機能を備える。
概念辞書の役割は「AIの誤解を減らし、影響範囲の漏れを減らす」ことである。

### 1.4 AI・人間・コーディングエージェントの役割分担

| 担当 | 役割 | 具体例（A画面→B(DB)→C画面の変更） |
|------|------|----------------------------------|
| 人間 | 変更要求の起点、レビュー、最終確定 | 「A画面の表示項目を追加したい」を起票し、影響範囲候補をレビューして確定する |
| アプリ内AI | 影響範囲の検出、変更計画の策定、指示パッケージの生成 | A→B→Cの依存を分析し、「A, B, Cすべて修正が必要」と提案。各ファイルの変更内容と整合性制約を生成する |
| コーディングエージェント | 指示された範囲の精緻な実装 | 指示パッケージに従い、A, B, Cを修正する。指示に含まれていればC画面も直すが、含まれていなければ直さない |

本ツールの成否は「アプリ内AIが影響範囲を漏らさないこと」と「人間が漏れを検出できるレビュー体験を提供すること」にかかっている。
コーディングエージェントは優秀な実行者だが、指示の品質がボトルネックになる。

### 1.5 根拠提示の要件（レビューを成立させる）

AIが候補（影響範囲・変更内容・受入条件）を提示する際、レビューが形骸化しないために根拠は必須とする。

- どの既存要件/設計/UX仕様のどの記述にヒットしたか（引用箇所）
- どの概念辞書エントリにマッチしたか
- なぜその影響（システム領域/機能・設計成果物・ファイル）に波及するかの因果説明
- 根拠から原文へ遷移できること
- 根拠と確信度を構造化データとして保持・エクスポート可能であること

### 1.6 影響分析とsuspect link（要再確認）の品質方針

本ツールの最大リスクは「漏れ」である。よって影響検出はPrecisionよりRecallを優先する（漏れ最小化）。
過検知は許容し、AIのランキング・クラスタリング・根拠提示により、人間が確定しやすい形に削る。

また、要件・設計・UX仕様・実装参照が更新された場合、関連リンクに「要再確認（suspect）」を付与する。
ただしフラグが多すぎると運用が破綻するため、以下を保持・表示する。
- リンクごとの最終確認時点
- 重大度（高/中/低）と優先表示（高を最優先）
- 一括確認UIで効率的に消化できる導線

#### 1.6.1 正解データ（評価基盤）の保持

変更要求ごとに、人間が最終確定した「影響範囲（業務要件・システム要件・システム機能・設計成果物・画面/遷移/UX仕様・ファイル）」を正解データとして保存する。
AI提案の漏れ/過検知をこの正解データで評価し、継続改善の基盤とする。

### 1.6.2 双方向影響分析（トップダウン＋ボトムアップ）

影響分析は一方向（要件→実装）だけでなく、双方向で行う。これにより正本のつながりが不完全でも、コード側から補完できる。

#### トップダウン（正本起点）
```
変更要求
  ↓ 正本で辿る
業務要件
  ↓ 正本で辿る
システム要件
  ↓ 正本で辿る
エントリポイント
  ↓ コード解析で展開
依存ファイル群
```

#### ボトムアップ（コード起点の逆流）
```
コード解析で検出した依存ファイル
  ↓ エントリポイントと突合
システム機能（正本に登録済みなら）
  ↓ 正本で逆引き
システム要件
  ↓ 正本で逆引き
業務要件
  ↓ 人間に提案
「この業務要件も影響範囲に含めますか？」
```

#### 逆流提案の例

変更要求「売上伝票計上の消費税仕訳の仕様変更」の場合：

1. トップダウンで `SR-SD-010（売上消費税仕訳）` → `/app/sd/tax-journal/` を特定
2. コード解析で `TaxJournalService.ts` が共通処理であり、仕入伝票からも呼ばれていることを検出
3. ボトムアップで `/app/mm/tax-journal/` → `SR-MM-008（仕入消費税仕訳）` → `BR-MM-001（仕入計上）` を逆引き
4. AIが提案：「消費税仕訳の共通処理を変更すると、仕入伝票計上にも影響します。SR-MM-008、BR-MM-001も影響範囲に含めますか？」

#### 逆流が機能する条件

エントリポイント → システム機能 → システム要件 → 業務要件 の逆引きができること。

正本に登録されていないエントリポイント（コード領域）は逆流が機能しない。したがって、エントリポイントの網羅性は意識的に担保する必要がある（ヘルススコアで監視）。

### 1.7 スコープ外

- テストケース管理・テスト実行管理ツールの機能はスコープ外
  - テストケースの詳細設計（手順、期待値、データ準備等）は外部ツールで行う
  - テスト実行結果の管理（パス/フェイル、実行日時、環境等）は外部ツールで行う
  - ただし、受入条件の「確認状態」と「確認根拠（外部ツールへのリンク含む）」は本ツールで追跡する
- 受入条件のlint（曖昧表現検知、検証可能性チェック、警告表示）はスコープ内
  - 「検証可能に書かれているか」のチェックは本ツールが行う
  - 「実際に検証されたか」の状態追跡も本ツールが行う
  - 「どのように検証するか」の詳細設計は外部ツールに委ねる
- 認証/権限の本格実装、組織運用（承認フローの厳格化）はモック段階では優先しない（将来拡張）

### 1.8 データ永続化（MVP段階）

- MVP段階の永続化はSupabaseを使用
- 対象テーブル
  - 業務一覧（business_domains）
  - 業務タスク（business_tasks）
  - 業務要件（business_requirements）
    - priority（優先度）を追加
    - acceptance_criteria を構造化（確認状態・検証手段・確認者・確認日時・確認根拠を含む）
    - （移行メモ）既存 `acceptance_criteria(text[])` との互換のため、MVP段階では `acceptance_criteria_json(jsonb)` を併設して段階移行する
  - システム領域マスタ（system_domains）
  - システム機能一覧（system_functions）
    - entry_points を構造化（path / type / responsibility を含む）
    - （移行メモ）既存 `code_refs.paths` から `entry_points[].path` を暫定移行する（type/responsibility は後で入力）
  - システム要件（system_requirements）
    - category（観点種別: function / data / exception / auth / non_functional）を追加
    - business_requirement_ids（紐づく業務要件ID）を追加
    - acceptance_criteria を構造化（確認状態・検証手段・確認者・確認日時・確認根拠を含む）
    - （移行メモ）既存 `acceptance_criteria(text[])` との互換のため、MVP段階では `acceptance_criteria_json(jsonb)` を併設して段階移行する
  - 概念辞書（concepts）
  - 変更要求（change_requests）
  - 影響範囲（impact_scopes：業務要件・システム要件・システム機能・設計/UX/ファイル）
  - 正解データ（impact_ground_truth：人間確定の影響範囲）
- CRUDは開発用途の匿名キーで実行（本番運用の認証は将来拡張）

---

## 2. プロダクト戦略（ユーザー価値と運用）

本章は、画面設計の前提となる「誰の、どの仕事（ジョブ）を、どの順序で、何をもって成功とするか」を定義する。

### 2.1 想定ユーザーと利用文脈

- 主要ユーザー: あなた（業務ITコンサルタント/開発責任者）
- 次期ユーザー: あなたの社員となる業務ITコンサルタント
- 利用文脈: コーディングエージェントを活用した案件開発において、ヒアリング起点で要件を体系化し、設計・実装・変更要求まで一貫して“正本”を参照して進める

本ツールが解くべき中心課題は、コーディングエージェントが開発中に必要な体系的コンテキスト（業務要件/システム要件/設計の全体整合）を把握できず、整合性を崩した実装・誤った改修をしてしまうリスクである。現状のコーディングエージェントは、プロジェクト全体の正本を十分に参照できない状態だと、局所最適の変更を積み上げて破綻しやすい。

加えて、変更要求フェーズでは「影響範囲（特に実装ファイル）の漏れ」により改修漏れ/誤改修が発生し、受入条件（業務要件・業務フロー上の期待）を満たせなくなるリスクが顕在化する。

#### 運用上の役割（最小）

本ツールはAIやコーディングエージェントを使うが、最終的に事故を防ぐ鍵は「誰が何を確定/確認するか」を曖昧にしないことにある。
MVPでは同一人物が兼務してよいが、将来のチーム運用を見据えて最小限の役割を定義する。

| 役割 | 責務 |
|------|------|
| 起票者 | 変更要求やヒアリング断片を起票し、背景・目的・期待・制約を残す |
| レビュア/確定者 | 影響範囲・変更内容・受入条件をレビューし、「確定」する（正本に残す） |
| 受入確認者 | 受入条件の確認（OK/NG判定）と確認根拠を残す |
| 実装者（コーディングAI） | 確定済み指示パッケージに従い実装する（指示範囲外は原則触らない） |

### 2.2 主要ユースケース（ユーザージャーニー）

本節では、フェーズごとに「クライアント／あなた（コンサル）／アプリ内AI／コーディングAI」が何を入力し、何を決め、何を成果物として残すかを定義する。

MVPでは特に、既存案件の変更要求を「壊さず通す」ためのフェーズE〜H（変更要求起票→影響分析→変更内容確定→受入→ベースライン反映）を最優先で磨く。
フェーズA〜D（新規要件の体系化〜初期実装）はプロジェクトによって必要だが、MVPでは「変更要求を回せるだけの最小の正本」を優先する。

#### 2.2.1 フェーズA: 断片ヒアリング → 業務要件（業務タスク＋業務受入条件）の体系化

| 役割 | 主な行動 | 主要アウトプット（正本に残すもの） |
|------|----------|----------------------------------|
| クライアント | 背景・目的・現状の困りごと・例外・制約を断片的に提示（口頭含む） | ヒアリング断片、用語、例外、制約 |
| あなた（コンサル） | 断片を入力し、業務タスクへの分解方針と粒度を決める。候補をレビューして最終確定する | 業務タスク、業務要件、業務受入条件（検証可能な条件） |
| アプリ内AI | 追加質問案、穴埋め案、業務タスク分解案、業務受入条件案を根拠付きで提示する | 候補（差分）＋根拠＋確信度 |
| コーディングAI | 原則このフェーズでは実装しない（参照のみ） | - |

#### 2.2.2 フェーズB: システム要件（機能＋データ＋例外＋権限＋非機能）の体系化

| 役割 | 主な行動 | 主要アウトプット（正本に残すもの） |
|------|----------|----------------------------------|
| クライアント | 要望（例：帳票、権限、監査、外部連携、性能）を追加提示。優先度や制約を明確化する | 制約、優先度、例外、非機能期待 |
| あなた（コンサル） | 業務要件との対応関係（なぜこのシステム要件が必要か）をレビューし、漏れがない形で確定する | システム要件、システム受入条件、業務要件↔システム要件のリンク |
| アプリ内AI | 機能/データ/例外/権限/非機能の観点で穴を検知し、受入条件案とともに候補提示する | 候補（差分）＋根拠＋確信度 |
| コーディングAI | 原則このフェーズでは実装しない（参照のみ） | - |

#### 2.2.3 フェーズC: 設計（設計書・画面/遷移/UX仕様）の整備

| 役割 | 主な行動 | 主要アウトプット（正本に残すもの） |
|------|----------|----------------------------------|
| クライアント | 画面/運用/例外時の期待（UX含む）を確認し、合意する | 画面・遷移・運用上の期待（合意点） |
| あなた（コンサル） | 要件と設計の整合をレビューし、「変更時に影響判断できる粒度」を満たすまで確定する | 設計書、画面/遷移/UX仕様、設計↔要件リンク |
| アプリ内AI | 設計の雛形や差分案、要件との矛盾・不足の指摘、根拠整形を行う | 候補（差分）＋根拠＋確信度 |
| コーディングAI | 参照のみ（この時点の設計を後工程で遵守するための理解） | - |

#### 2.2.4 フェーズD: 実装指示パッケージ作成 → コーディングAIで実装

| 役割 | 主な行動 | 主要アウトプット（正本に残すもの） |
|------|----------|----------------------------------|
| クライアント | 受入観点（ここが満たされないとNG）を最終確認する | 受入の合意（業務受入条件の確定） |
| あなた（コンサル） | 実装方針・優先度・リスクを確定し、指示パッケージを最終確定する | コーディングAI向け指示（確定版） |
| アプリ内AI | コーディングAIが道を外れないための情報を機械可読に出力する | 実装指示パッケージ（下記） |
| コーディングAI | 指示パッケージを参照して実装し、受入条件を満たすよう修正する | 実装変更（PR/コミット）、変更ファイル、実装メモ |

実装指示パッケージに含めるべき最小要素は次のとおり。
- 変更対象ファイル候補（パス）と優先度
- 変更内容案（差分の意図、制約、禁止事項）
- 受入条件（業務/システム。何がOKなら完了か）
- 根拠（要件・設計・UX仕様への参照）
- 全体整合のための前提（用語、制約、非機能、例外、関連する設計判断）

#### 2.2.5 フェーズE: 変更要求の起票（何を変えたいかの確定）

| 役割 | 主な行動 | 主要アウトプット（正本に残すもの） |
|------|----------|----------------------------------|
| クライアント | 追加/変更したい業務要件・運用・制約を提示する（背景/目的/期待を含む） | 変更要求（背景/目的/期待）、関連するヒアリング断片 |
| あなた（コンサル） | 変更要求のスコープと優先度を整理し、受入条件（業務側の期待）を更新・確定する | 更新された業務受入条件、変更要求のスコープ（暫定） |
| アプリ内AI | 不足情報を指摘し、追加質問案と「変更要求により追加/更新される受入条件案」を根拠付きで提示する | 追加質問案、受入条件案（差分）＋根拠＋確信度 |
| コーディングAI | 原則このフェーズでは実装しない（参照のみ） | - |

#### 2.2.6 フェーズF: 影響分析（影響範囲の確定＝正解データ化）

| 役割 | 主な行動 | 主要アウトプット（正本に残すもの） |
|------|----------|----------------------------------|
| クライアント | 影響がありそうな業務・画面・例外の観点を補足する（あれば） | 影響観点の補足 |
| あなた（コンサル） | 影響範囲（システム領域/機能・要件・設計・画面/UX・ファイル）を最終確定する（＝正解データ） | 影響範囲（正解データ）、影響理由（根拠） |
| アプリ内AI | Recall最優先で影響範囲候補を提示し、根拠（引用＋因果）と確信度、候補のクラスタリング/優先度付けを行う | 影響範囲候補＋根拠＋確信度（差分提案） |
| コーディングAI | 原則このフェーズでは実装しない（参照のみ） | - |

#### 2.2.7 フェーズG: 変更内容の確定 → 実装指示パッケージ作成 → コーディングAIで改修

| 役割 | 主な行動 | 主要アウトプット（正本に残すもの） |
|------|----------|----------------------------------|
| クライアント | 期待する振る舞い/画面/例外の最終確認（必要なら） | 期待の最終合意 |
| あなた（コンサル） | 変更内容（何をどう変えるか）と受入条件を最終確定し、指示パッケージを確定する | 変更内容（確定版）、指示パッケージ（確定版） |
| アプリ内AI | 影響範囲（正解）に基づき、変更内容案とコーディングAI向け指示パッケージを生成する（整合前提を明示） | 変更内容案＋根拠、指示パッケージ案 |
| コーディングAI | 指示パッケージに従って改修し、受入条件を満たすよう修正する | 実装変更（PR/コミット）、変更ファイル、実装メモ |

#### 実装指示パッケージの検証観点

指示パッケージの品質がコーディングエージェントの実装品質を決める。人間が確定前にチェックすべき項目は以下。

| 検証観点 | チェック内容 | 不備時のリスク |
|---------|-------------|---------------|
| 影響範囲の網羅性 | 影響範囲に含まれるすべてのファイルが、変更対象として指示に含まれているか | 漏れたファイルは修正されない |
| 受入条件との紐づけ | 各ファイルの変更意図が、対応する受入条件と紐づいているか | 何のための変更かが不明確になる |
| 整合性制約の明示 | 依存関係のあるファイル間で、整合性制約が明示されているか（「Bを変えるならCのここも確認」） | 整合性が崩れる |
| 禁止事項の明示 | 変更してはいけない制約（既存機能への影響回避）が明示されているか | 意図しない副作用 |
| 逆流提案の反映 | ボトムアップで検出された追加影響が、指示に含まれているか | 共通処理の変更が下流に波及しない |

これらが欠けた指示パッケージは、コーディングエージェントの実装品質に関わらず波及影響を見落とす。

#### 2.2.8 フェーズH: 受入（受入条件ベース）→ ベースライン反映 → suspect消化

| 役割 | 主な行動 | 主要アウトプット（正本に残すもの） |
|------|----------|----------------------------------|
| クライアント | 受入条件に基づいて受入可否を判断する（またはあなたが代理で確認する） | 受入条件ごとの確認結果（OK/NG）と確認根拠 |
| あなた（コンサル） | すべての受入条件が「確認済み」になったことを確認し、ベースライン（版）への適用を確定する。NGがあれば差し戻す。必要に応じてsuspect linkを消化する | 版適用履歴、suspect消化履歴 |
| アプリ内AI | 未確認の受入条件を警告表示し、確認漏れを防ぐ。suspect linkの優先度付けと一括確認導線を提示する | 未確認リスト、suspectの優先リスト |
| コーディングAI | NGが残る場合のみ追加改修する | 追加実装変更 |

受入の完了条件:
- 影響範囲に紐づくすべての受入条件が「確認済み」である（未確認がゼロ）
- 確認済みの受入条件がすべてOKである（NGがゼロ）
- 上記2条件を満たした状態で、ベースライン（版）への適用が確定されている

未確認の受入条件が残っている状態でベースライン反映を試みた場合、本ツールは警告を表示する（MVP段階では警告のみ、強制ブロックはしない）。

### 2.3 価値仮説（なぜこのプロダクトが必要か）

- 正本の一元化: 要件・設計・UX仕様・実装参照を一貫した構造で保持し、参照先の分断をなくす
- 漏れ最小化: 影響分析はRecall最優先とし、根拠提示とレビューにより現実的に運用可能な形へ落とし込む
- 継続改善: 変更要求ごとに人間が確定した影響範囲を正解データとして保持し、AI提案の品質を定量評価できる状態を作る

Notion/Excel/Jira等でも情報は管理できるが、これらは「コーディングエージェントが誤改修しないために必要な、影響範囲（ファイル含む）・根拠・受入条件の確認状態」を一貫した構造で保持しづらい。
本ツールは変更要求を中心に、確定データと根拠を蓄積し、コーディングエージェントへ渡せる形で出力できることを差別化点とする。

### 2.3.1 検証すべき前提（リスクと検証方針）

本プロダクトの価値仮説は、以下の前提が成立することに依存している。MVPでは実案件を通じてこれらを検証し、成立しない場合は設計を見直す。

#### 前提1：正本維持のコストがペイする

正本（業務要件・システム要件・エントリポイント・概念辞書）を維持するコストが、コーディングエージェントの誤改修を防いだことによる削減工数を下回る必要がある。

| 検証指標 | 目標 |
|---------|------|
| 正本整備の初期コスト | 変更要求を回せる最小限の正本整備に要する時間 |
| 正本維持の継続コスト | 変更要求1件あたりの正本更新時間（suspect消化含む） |
| 削減効果 | 誤改修・手戻りの発生率と修正コスト |

検証方針：最初の実案件で上記を計測し、コスト対便益が成立しない場合は正本の範囲を縮小する。

#### 前提2：コールドスタート問題を乗り越えられる

「正本がない状態から変更要求を回せる」設計が必要。全体を整備してから始めるのではなく、変更要求を回しながら正本を育てる。

検証方針：正本がほぼ空の状態から変更要求を起票し、影響分析→正本追加→次の変更要求という「育成ループ」が実際に回るかを検証する。

#### 前提3：AI影響分析の精度が運用に耐える

影響分析の過検知率が高すぎるとレビュー疲れで形骸化する。

| 検証指標 | 目標（暫定） |
|---------|-------------|
| 過検知率 | 影響候補のうち、実際には不要だったものが50%以下 |
| 漏れ率 | 人間が確定した影響範囲のうち、AIが提案しなかったものが10%以下 |

検証方針：変更要求ごとに正解データ（人間確定の影響範囲）を蓄積し、AI提案との差分を計測する。過検知率が高い初期段階では、クラスタリングと優先度付けでレビュー負荷を下げる。

#### 前提4：コーディングエージェントの能力仮定が維持される

本ツールは「コーディングエージェントは指示範囲外を自発的に見ない」という前提に立っている。この前提が崩れた場合（コーディングエージェントが自律的に波及影響を検出できるようになった場合）、本ツールの役割は「影響検出」から「業務文脈の正本管理」にシフトする。

検証方針：コーディングエージェントの進化を継続的にウォッチし、能力仮定を半年ごとに見直す。

### 2.4 MVPスコープ（段階導入）

MVPの勝ち筋は、既存案件の変更要求を「壊さず通す」こと（フェーズE〜H）で価値を立証することである。よってMVPは変更要求中心に構成する。

- MVPで必ず提供すること
  - 変更要求の起票〜影響分析〜変更確定〜受入（確認状態/根拠）〜ベースライン反映（版）までの運用
  - 影響範囲の提案と確定（システム領域/機能・要件・設計/UX・ファイル）およびコーディングエージェント向け出力
  - 正解データ（人間確定の影響範囲）の保存
  - 最小限の正本整備: 変更要求を回すために必要な範囲で、業務要件/システム要件・設計/UX仕様を保持できる

- MVPでは優先しないこと
  - 既存Excelの取り込み（B）
  - テスト管理（テストケース/実行結果の追跡）
  - 本番運用向けの厳格な認証/権限/承認フロー

### 2.5 成功指標（運用での判定）

本ツールの成功は、単なる画面の完成ではなく、実プロジェクトで次が成立することによって判定する。

- 変更要求適用後、影響範囲に紐づく受入条件がすべて「確認済み(OK)」である

上記のために、変更要求ごとに「影響範囲の最終確定」と「受入条件の確定」を必須の運用ゲートとする。

### 2.6 前提・制約（MVPの意思決定）

本プロダクトは「要件の百科事典」を目指す前に、まず「変更要求で壊さない」ことに集中する。そのため、MVPでは次を前提とする。

- 利用単位: 1プロジェクト（=1案件/1プロダクト）を基本とし、プロジェクト横断（複数案件の同居）はMVPでは扱わない
- 利用者: 個人〜少人数を主対象とし、厳格な権限分離や承認フローは将来拡張とする
- 正本の境界: 「意図の正本」は本ツールで確定したもののみ正とする（外部ツール/リポジトリは参照先＝現実の正本）。意図と現実の差分はsuspect linkと変更要求で管理し、確定情報は本ツールへ戻す
- 機密性: 顧客情報を含む可能性があるため、LLMへ送信する入力範囲はユーザーが可視化・制御できることを前提とする（少なくとも「どの原文を根拠として送るか」を表示）
- 既存ツール連携: GitHub/Notion等との自動連携は段階導入とし、MVPはURL/パス/メモの手入力でも成立することを優先する

### 2.7 用語定義（最低限）

本PRDでは「領域」「要件」「機能」という言葉が混同しやすいため、以降は次の用語で区別する。

| 用語 | 定義 | 例 |
|------|------|----|
| 業務（分類） | 業務上の分類ラベル。業務タスクの束ね方 | 請求、入金消込、購買 |
| 業務タスク | 業務側のジョブ単位。業務要件の束ね方 | 請求書発行、売上計上 |
| 業務要件 | 業務タスクを成立させる要件。業務受入条件を含む | 「請求書をPDFで出力できる」 |
| システム領域 | システム側のモジュール/責務境界 | SD請求、FI会計、認証 |
| システム機能 | システム領域内の機能カタログ。人間が認識しやすい機能単位（画面/バッチ/API等）であり、システム要件の親となる | 仕訳登録画面、請求書出力バッチ、税計算API |
| システム要件 | システム機能を成立させる個々の要件。機能＋データ＋例外＋権限＋非機能を含む。1つ以上の業務要件に紐づく | 「仕訳登録時にIFRS/JGAAPの元帳を指定できる」「登録前にエラーチェックが走る」 |
| 変更要求 | 仕様変更の単位（イベント）。影響範囲・変更内容・受入条件・根拠を確定する対象 | 「インボイス対応」 |
| 影響範囲 | 変更要求が波及する対象の集合。業務要件・システム要件・システム機能・設計成果物・画面/遷移/UX仕様・ファイルを含む | 「BR-BIL-001, SR-BIL-002, SF-BIL-010, /app/billing/*」 |
| 受入条件 | 要件（業務/システム）が満たされているかを判定するための、検証可能な条件 | 「請求書PDFに登録番号が印字されていること」 |
| 根拠（evidence） | 候補提示の出典と推論（引用箇所、概念ヒット、因果）を構造化したもの | 要件IDと該当スパン |
| suspect link | 更新により再確認が必要になったリンク。重大度（高/中/低）を持つ | 「要件A更新→要件Bが要再確認」 |

#### データ構造上の親子関係

本ツールのデータ構造は以下の親子関係を持つ。

業務（分類）
└─ 業務タスク
└─ 業務要件（業務受入条件を含む）
└─ [リンク] システム要件システム領域
└─ システム機能（親）
└─ システム要件（システム受入条件を含む）
└─ [リンク] 業務要件

システム要件は「システム機能の配下」に属し、かつ「1つ以上の業務要件にリンク」する。これにより、業務要件→システム要件→システム機能の双方向トレーサビリティを実現する。

### 2.7.1 エンティティ属性定義

本節では、各エンティティの属性、粒度判断基準、十分性基準を定義する。
これらは影響分析の精度に直結するため、データ登録時に遵守する。

#### 業務タスク（business_tasks）

| 属性 | 必須 | 説明 |
|------|------|------|
| id | ○ | 一意識別子（TASK-XXX） |
| business_id | ○ | 所属する業務分類 |
| name | ○ | タスク名（20字以内） |
| summary | ○ | 業務概要＋業務フロー（Markdown、200〜500字目安） |
| person | ○ | 主担当者（ロール名） |
| input | ○ | 業務のインプット（カンマ区切り） |
| output | ○ | 業務のアウトプット（カンマ区切り） |

##### 粒度判断基準

以下のいずれかが異なれば、業務タスクを分割する。

- 担当者（ロール）が異なる
- 実行タイミング（日次/月次/随時）が異なる
- インプットまたはアウトプットが独立している

##### 十分性基準

「この業務タスクの記述だけで、関連するシステム機能を特定できるか」を自問する。
業務フローに登場するシステム操作（画面操作、帳票出力、バッチ実行等）が明記されていれば十分。

---

#### 業務要件（business_requirements）

| 属性 | 必須 | 説明 |
|------|------|------|
| id | ○ | 一意識別子（BR-XXX-XXX） |
| task_id | ○ | 所属する業務タスク |
| title | ○ | 要件名（「〜できること」形式、30字以内） |
| summary | ○ | 要件の詳細（100〜200字） |
| priority | ○ | 優先度（Must / Should / Could） |
| concept_ids | ○ | 関連する概念辞書のID（1件以上推奨） |
| impacts | ○ | 影響するシステム領域（1件以上推奨） |
| acceptance_criteria | ○ | 受入条件（構造化形式、1件以上必須） |
| related_system_requirement_ids | - | 紐づくシステム要件ID |

##### 粒度判断基準

以下を満たす単位で分割する。

- 1つの受入条件セットで検証できる範囲
- 独立して「満たす/満たさない」を判定できる単位

##### 十分性基準

concept_ids と impacts が空の場合、影響分析のマッチングが効かない。
登録時に空の場合は警告を表示する（ブロックはしない）。

---

#### システム機能（system_functions）

| 属性 | 必須 | 説明 |
|------|------|------|
| id | ○ | 一意識別子（SRF-XXX） |
| system_domain_id | ○ | 所属するシステム領域 |
| title | ○ | 機能名（30字以内） |
| category | ○ | 機能種別（screen / batch / api / job / interface） |
| summary | ○ | 機能概要（200字程度） |
| status | ○ | 実装状態（not_implemented / implementing / testing / implemented） |
| entry_points | ○ | エントリポイント群（構造化形式、1件以上必須） |
| system_design | - | 設計項目（JSONB） |

##### エントリポイントの構造

システム機能は業務単位で管理し、エントリポイントに種別と責務を持たせる。
影響分析の絞り込みはエントリポイントの type と responsibility で行う。

（DB表現）entry_points は jsonb の配列として保持する（default `[]`）。
```json
[
  {
    "path": "/app/billing/invoice/page.tsx",
    "type": "screen",
    "responsibility": "発行指示、一覧表示"
  },
  {
    "path": "/jobs/invoice-pdf-batch.ts",
    "type": "batch",
    "responsibility": "PDF生成、税計算、登録番号出力"
  }
]
```

| 属性 | 必須 | 説明 |
|------|------|------|
| path | ○ | リポジトリ内のファイルパス |
| type | ○ | 種別（screen / batch / api / job / template / service） |
| responsibility | ○ | このエントリポイントが担う処理（20字程度） |

##### 粒度判断基準

システム機能は業務単位で管理する（画面/バッチ/APIごとに分割しない）。

分割が必要なケース：
- 業務上の意味が異なる（例：請求書発行 vs 請求書照会）
- 変更要求の影響が独立している

##### 十分性基準

entry_points が空、または responsibility が未記入の場合、影響分析の絞り込みが効かない。
登録時に警告を表示する。

---

#### システム要件（system_requirements）

| 属性 | 必須 | 説明 |
|------|------|------|
| id | ○ | 一意識別子（SR-XXX-XXX） |
| srf_id | ○ | 所属するシステム機能 |
| task_id | - | 関連する業務タスク（逆引き用） |
| category | ○ | 観点種別（function / data / exception / auth / non_functional） |
| title | ○ | 要件名（「〜できること」形式、30字以内） |
| summary | ○ | 要件の詳細（100〜200字） |
| concept_ids | ○ | 関連する概念辞書のID |
| impacts | ○ | 影響するシステム領域 |
| acceptance_criteria | ○ | 受入条件（構造化形式、1件以上必須） |
| business_requirement_ids | ○ | 紐づく業務要件ID（1件以上必須） |

##### 観点種別（category）の定義

| 種別 | 説明 | 記載内容 |
|------|------|---------|
| function | 何ができるか | システムの振る舞い。「〜できること」 |
| data | 何を扱うか | 入出力データの項目、形式、制約、計算ルール |
| exception | 異常時にどう振る舞うか | エラー、警告、境界条件、リカバリ |
| auth | 誰が使えるか | ロール、承認、操作制限 |
| non_functional | どのくらいの品質か | 性能、可用性、保守性、セキュリティ |

##### 粒度判断基準

1つのシステム機能に対して、観点種別ごとに要件を洗い出す。
観点が混在した要件は分割する。

##### 十分性基準

business_requirement_ids が空の場合、「なぜこのシステム要件が必要か」が不明になる。
登録時に空の場合は警告を表示する。

新規登録時、AIが「この機能要件に対応する例外要件はありますか？」と促す。

---

#### 受入条件の構造（共通）

業務要件・システム要件の acceptance_criteria は「オブジェクト配列」として保持する。

（DB表現）acceptance_criteria は jsonb の配列として保持する（default `[]`）。
```json
[
  {
    "id": "AC-001",
    "description": "請求書に登録番号が表示されること",
    "verification_method": "目視確認",
    "status": "unverified",
    "verified_by": null,
    "verified_at": null,
    "evidence": null
  }
]
```

| 属性 | 必須 | 説明 |
|------|------|------|
| id | ○ | 受入条件ID（親ID-AC-連番） |
| description | ○ | 検証可能な条件文 |
| verification_method | ○ | 検証手段（目視確認 / 自動テスト / 外部ツール参照） |
| status | ○ | 確認状態（unverified / ok / ng） |
| verified_by | - | 確認者 |
| verified_at | - | 確認日時 |
| evidence | - | 確認根拠（スクリーンショットURL、テスト結果リンク等） |

---

#### 概念辞書（concepts）

| 属性 | 必須 | 説明 |
|------|------|------|
| id | ○ | 一意識別子（C-XXX） |
| name | ○ | 概念名（正式名称） |
| synonyms | ○ | 同義語・別名（配列、1件以上推奨） |
| areas | ○ | 影響するシステム領域（配列、1件以上必須） |
| definition | ○ | 定義（Markdown、要件・ルール・関連法令を含む） |
| related_docs | - | 必読ドキュメントのパス |

##### 十分性基準

synonyms が空だと、自然言語での検索やマッチングが効きにくい。
業務用語とシステム用語の両方を登録することを推奨。

### 2.8 運用フロー（ゲートと状態遷移）

LLM候補生成を「思考」ではなく「差分提案」として運用に落とすため、MVPでは次のゲートを置く。

- AIが生成するものは常に「候補」であり、確定は必ず人間が行う
- 「確定」された要素のみがエクスポート対象（コーディングエージェントに渡す正本）となる
- 変更要求の最小完了条件は次の同時成立
  - 影響範囲（正解データ）が確定している
  - 変更内容が確定している
  - 変更要求に紐づく受入条件が確定している
  - 影響範囲に紐づくすべての受入条件が「確認済み」である（未確認がゼロ）
  - 受入条件ベースで受入OKになっている（確認済み(NG)がゼロ）
  - ベースライン（版）へ適用済である（適用履歴が残る）
- suspect link（重大度：高/中）は放置すると正本の信頼性が崩壊するため、「次の変更要求を開始する前に消化する」運用を推奨する（MVPでは強制はしない）

### 2.8.1 正本のヘルススコア（品質監視）

正本のつながりが不完全だと影響分析の精度が落ちる。以下を自動検出し、ダッシュボードに表示する。

#### 構造的なつながりのチェック

| チェック項目 | 重要度 | 検出方法 |
|-------------|-------|---------|
| 業務要件にシステム要件が紐づいていない | 高 | related_system_requirement_ids が空 |
| システム要件に業務要件が紐づいていない | 高 | business_requirement_ids が空 |
| システム機能にエントリポイントが未設定 | 高 | entry_points が空 |
| エントリポイントに responsibility がない | 中 | responsibility が空文字 |
| 概念辞書の用語が要件文中に出現するのにリンクがない | 中 | テキストマッチ |
| suspect linkが一定期間放置されている | 中 | 最終確認日時 |
| 変更要求で確定した影響範囲と、正本上のつながりに矛盾がある | 中 | 差分検出 |

#### データ品質のチェック

| チェック項目 | 重要度 | 検出方法 |
|-------------|-------|---------|
| 業務要件に concept_ids がない | 高 | 配列が空 |
| 業務要件に impacts がない | 高 | 配列が空 |
| システム要件に category（観点種別）がない | 高 | null または未設定 |
| 受入条件が0件 | 高 | acceptance_criteria が空 |
| 受入条件がlint警告を受けている（検証可能性が低い） | 高 | lint結果 |

ヘルススコアは「正本の信頼性」を可視化するものであり、100%を目指すものではない。変更要求を回しながら徐々に改善する。

なお、ヘルススコアが著しく低い状態（エントリポイント登録率30%未満、観点種別未設定率50%超など）で影響分析を実行した場合、本ツールは「影響分析の精度が低下している可能性があります」と警告を表示する。

### 2.8.2 変更要求起点の正本育成フロー

正本は最初から完璧に整備するのではなく、変更要求を回しながら育てる。
```
変更要求「インボイス対応」
  ↓
影響分析（トップダウン）
  → 正本に登録されていないシステム機能を発見
  → 「このエントリポイントをシステム機能として登録しますか？」
  ↓
影響分析（ボトムアップ・逆流）
  → 正本にないつながりを発見
  → 「このシステム要件と業務要件をリンクしますか？」
  ↓
影響範囲の確定
  → 確定した影響範囲を正解データとして保存
  → 正本のつながりを更新（オプション）
  ↓
次の変更要求
  → 前回の学習が活きる
```

この「育成ループ」により、変更要求を回すほど正本が充実し、影響分析の精度が上がる。

### 2.9 非機能・品質要件（MVP）

- 根拠がない候補は出さない: 根拠が不足する場合は「不足情報」と「追加質問」を提示する
- レビューが成立すること: 候補提示は「一括で確定/却下できる粒度」とし、過検知を許容してもレビュー作業が破綻しないUIを優先する
- 変更要求あたりのレビュー時間の目安: 影響範囲の確定まで30〜60分で回ること（回らない場合は表示/クラスタリング/既定フィルタを改善する）
- 監査性: 「誰が・いつ・何を確定したか」を最低限追える（個人利用でも、後から自分が再現できることが重要）
- 性能（目標）: 照会検索の初回結果が3秒以内に表示される（再ランキングや詳細根拠は遅延ロード可）

### 2.10 主要リスクと対策方針

| リスク | 具体例 | 対策方針 |
|--------|--------|----------|
| 過検知によるレビュー疲れ | 影響候補が多すぎて確定できない | 重大度/確信度/クラスタリングで「まず見るべき」を絞る。既定フィルタで高重要度を先に出す |
| 漏れの見逃し | AI提案に含まれない影響が出る | 正解データを蓄積し、漏れを検知して改善する（1.6.1）/ 影響分析はRecall最優先（1.6） |
| 正本の陳腐化 | 更新が反映されず形骸化する | suspect link運用を前提にし、高/中だけを可視化・一括消化できる導線を用意する |
| 用語/領域の混同 | 業務領域とシステム領域が混ざり、検索/影響分析が崩れる | 用語定義を固定（2.7）。UI/データで明示的に区別し、ID体系も分ける |
| 機密情報の取り扱い | 顧客固有情報がLLMに送られる/ログに残る | 送信対象の可視化と最小化を前提に設計（2.6）。必要に応じて伏字/要約モードを用意する |

---

## 3. 画面構成（MVP / 現行Next.js実装準拠）

本章は、2章までの方針（変更要求を壊さず通す＝フェーズE〜H優先）を前提にしつつ、現行Next.js実装（ルーティング/画面）に合わせて画面構成を整理する。
ただし現状では、変更要求と版管理は「UIは存在するが運用できる状態ではない」ため、当面は提供中/準備中を明確に分け、誤解や運用崩壊（正本の信頼性低下）を防ぐ。

### 3.1 共通レイアウトとナビゲーション

全画面で共通のサイドメニュー（PC）と、モバイル用ヘッダー＋スライドメニュー（SP）を使用する。
設定画面は設定専用の左メニュー（設定サブナビ）を持つ。

| 区分 | メニュー | ルート | 目的 | 提供状態（現行） |
|------|----------|--------|------|----------------|
| 主要 | ダッシュボード | `/dashboard` | 状況把握と「次にやること」の起点 | サンプル（準備中） |
| 主要 | 照会 | `/query` | 自然言語で横断的に探す（探索コスト削減） | サンプル（準備中） |
| 主要 | 業務一覧 | `/business` | 意図の正本の入口（業務→タスク→要件） | 提供中 |
| 主要 | 変更要求一覧 | `/tickets` | 変更要求（イベント）の入口（フェーズE〜H） | 準備中（UIのみ） |
| 主要 | ベースライン履歴 | `/baseline` | 版の参照（将来：版間差分/適用履歴） | 準備中（UIのみ） |
| 主要 | エクスポート | `/export` | 外部出力（将来：Claude Code連携。詳細は5章） | 準備中（UIのみ） |
| 管理 | 概念辞書 | `/ideas` | 概念（用語/同義語/影響領域）を育て、影響分析の精度を上げる | 提供中 |
| 管理 | システム領域一覧 | `/system-domains` | システム領域/機能カタログ（影響分析の観点軸） | 提供中 |
| 管理 | 設定 | `/settings` | プロジェクト/LLM等の設定 | 部分提供（設定の一部は将来） |

補足（KISS）: 本ツールは正本の信頼性が価値の中心であるため、「準備中（UIのみ）」はサイドメニューから非表示、または「準備中」ラベル付きで無効化する運用を推奨する。

設定サブナビ（`/settings/*`）:
- プロジェクト設定: `/settings`
- LLM設定: `/settings/llm`
- システム領域マスタ: `/settings/system-domains`
- 通知設定: `/settings/notification`

### 3.2 フェーズ別主要導線（現行→勝ち筋へ）

勝ち筋は、既存案件の変更要求を「壊さず通す」ためのフェーズE〜Hである。
一方で現行実装は、E〜Hを成立させる前提（意図の正本の整備）に比重がある。
よって、フェーズ1（提供中）→フェーズ2（準備中）として導線を分ける。

#### 3.2.1 フェーズ1（提供中）: 意図の正本を整備する

目的は、フェーズ2の影響分析・レビュー・受入を成立させるための「参照可能な正本」を最小コストで整えること。

- 業務/タスク/要件の整備: `/business` → `/business/{bizId}/tasks` → `/business/{bizId}/tasks/{taskId}/edit`
  - 業務要件/システム要件に受入条件を記述し、概念・システム領域/機能と紐づける
- システム領域/機能カタログの整備: `/settings/system-domains` → `/system-domains` → `/system-domains/{systemDomainId}/functions/create`
  - 機能単位で、設計項目やコード参照（パス）を保持できるようにする
- 概念辞書の整備: `/ideas`
  - 同義語と影響領域を育て、後工程の影響分析の漏れを減らす（1.3）

#### 3.2.2 フェーズ2（準備中）: 変更要求を壊さず通す（E〜H）

現時点では未実装だが、最初の薄いスライスは「手動でも成立する」ことを優先する（YAGNI）。
AI影響分析や自動差分は後追いでよい。

- フェーズE（起票）: `/tickets/create`
  - 背景/目的/期待、影響がありそうな業務・領域（暫定）を入力して変更要求を起票する
- フェーズF（影響範囲の確定）: `/tickets/{id}`
  - 影響範囲（業務・領域・要件・概念・ファイル）をまずは手動で確定できる状態にする
  - AIは候補提示に留め、根拠がない候補は出さない（2.9）
- フェーズG（変更内容の確定→指示パッケージ化）: `/tickets/{id}` / `/tickets/{id}/edit`
  - 変更内容（現行→変更後）と受入条件を確定し、コーディングエージェント向けの指示に落とす
- フェーズH（受入→版反映）: `/tickets/{id}` を中心に実現する
  - 最初は「版一覧/版間差分」を作り込む前に、変更要求への適用履歴とスナップショット（何が取り込まれたか）を残せれば成立する（KISS）
  - 未確認が残る状態は「判定不能」とみなす（1.1.1）

### 3.3 正本（意図の正本）メンテナンス（ベースライン仕様）

変更要求の影響分析を成立させるために、最小限の「意図の正本（要件・設計・受入条件・根拠）」を整備する。

#### 3.3.1 業務→タスク→要件（業務中心）

- 業務一覧: `/business`（作成/編集/削除）
- 業務一覧（詳細）＝業務タスク一覧: `/business/{bizId}/tasks`（作成/編集/削除）
- 業務タスク詳細: `/business/{bizId}/tasks/{taskId}`（業務要件・関連システム要件の参照）
- 業務タスク編集: `/business/{bizId}/tasks/{taskId}/edit`（業務要件・システム要件を含む編集）
- 業務タスク手動追加: `/business/manual-add?id={bizId}`（タスク＋業務要件の一括登録）
- AI修正指示（デモ）: `/business/{bizId}/tasks/ai-order`（ラフ入力→差分候補の提示。LLM連携は将来）

#### 3.3.2 システム領域→システム機能（カタログ中心）

- システム領域一覧: `/system-domains`（一覧/検索）
- システム領域マスタ管理: `/settings/system-domains`（作成/編集/削除）
- システム機能一覧（領域内）: `/system-domains/{systemDomainId}`（一覧/フィルタ/削除）
- システム機能 新規追加: `/system-domains/{systemDomainId}/functions/create`（システム要件と紐づけて登録）
- システム機能 詳細: `/system-domains/{systemDomainId}/{srfId}`（設計項目/コード参照/関連システム要件）
- システム機能 編集: `/system-domains/{systemDomainId}/{srfId}/edit`

#### 3.3.3 概念辞書（育てる）

- 概念一覧: `/ideas`
- 概念 新規追加: `/ideas/add`
- 概念 詳細/編集: `/ideas/{conceptId}` / `/ideas/{conceptId}/edit`
- 概念の統合/分割: UI導線はあるが、統合・分割の実処理は将来（1.3）

### 3.4 参照・補助画面

- ダッシュボード: `/dashboard`（サンプル。将来：レビュー待ち変更要求、suspect、クイックアクション）
- 照会: `/query`（サンプル。将来：根拠付き横断検索）
- ベースライン履歴: `/baseline`（準備中。将来：版間差分、取り込み変更要求、適用履歴）
- エクスポート: `/export`（準備中。将来：5章のClaude Code連携形式で出力）
- 設定: `/settings`（一部設定は将来。システム領域マスタは提供中）

---

## 4. 機能体系と実装状況（Next.js現行）

本章では、2章までの運用設計（変更要求中心）に合わせて機能体系を整理し、現行Next.js実装で「実装済/部分実装/未実装」が判別できる形で一覧化する。

### 4.1 実装状況の定義

| 実装状況 | 定義 |
|----------|------|
| 実装済 | 画面があり、主要操作が実データ（Supabase）で成立している |
| 部分実装 | 画面はあるが、モックデータ/静的表示/一部機能が未である |
| 未実装 | 画面・永続化・連携のいずれも未で、PRD上の要求のみがある |

### 4.2 実装状況一覧（画面/機能別）

#### 4.2.0 抜本方針（客観的提案）

現状の変更要求/版管理はUIが中心で、実プロジェクトでの運用（E〜H）にはまだ耐えない。
よって現行実装を段階導入する提供方針として、次を明示する。

- 提供中の価値は「意図の正本（ベースライン仕様の整備）」にある（4.2.2）
- 変更要求/版管理（4.2.1 / 4.2.3）は「準備中（UIのみ）」として扱い、メニュー表示は抑制する（3.1参照）
- 変更要求/版管理の実装は、フル機能ではなく「薄いスライス」を優先する（KISS / YAGNI）

薄いスライス（まず運用できる状態を作る）:

| カテゴリ | 先にやる（最小） | 後回し（YAGNI） |
|----------|------------------|------------------|
| 変更要求 | 永続化（起票/編集/状態/優先度/担当）、履歴（誰がいつ何を確定したか） | 承認フロー、権限、複数案件横断 |
| 影響範囲 | 手動で「業務/タスク/要件/概念/システム機能/ファイル」を確定できるUI + 根拠メモ | AI自動抽出/クラスタリング/確信度最適化 |
| 受入 | 受入条件ごとの確認状態（未確認/OK/NG）と確認根拠を保持（1.1.1） | テスト管理ツールの詳細連携 |
| 版管理 | 変更要求の「適用履歴」と「スナップショット（何を取り込んだか）」を残す | 版間差分の完全自動化、複数版同時適用、マージ戦略 |
| 指示パッケージ | コーディングエージェント向けの最小出力（影響範囲/変更内容/受入条件/根拠） | 5章の完全エクスポート、コード本文の自動取り込み |

#### 4.2.1 変更要求（イベント）

| 機能 | ルート | データ | 実装状況 | 備考 |
|------|--------|--------|----------|------|
| 変更要求一覧 | `/tickets` | モック | 部分実装 | 一覧UIはあり。フィルタはUIのみ |
| 変更要求 起票 | `/tickets/create` | モック | 部分実装 | 入力UIはあり。保存/永続化は未 |
| 変更要求 詳細 | `/tickets/{id}` | モック | 部分実装 | 影響範囲/変更内容/概念候補/版情報の表示はデモ |
| 影響分析（AI） | `/tickets/{id}` | - | 未実装 | ボタンはあるが分析・根拠生成は未 |
| 変更要求 編集 | `/tickets/{id}/edit` | モック | 部分実装 | UIはあるが「保存」はデモ |
| ベースライン反映（版適用） | `/tickets/{id}` | - | 未実装 | 反映ボタンはあるが、版適用の実処理/履歴は未 |
| 受入条件の確認状態追跡 | - | - | 未実装 | 1.1.1の確認状態（OK/NG/根拠）管理は未 |

#### 4.2.2 ベースライン仕様（意図の正本）

| 機能 | ルート | データ | 実装状況 | 備考 |
|------|--------|--------|----------|------|
| 業務一覧 | `/business` | Supabase | 実装済 | 一覧/検索/削除 |
| 業務 追加 | `/business/add` | Supabase | 実装済 | 自動採番して作成 |
| 業務 編集 | `/business/{bizId}/edit` | Supabase | 実装済 |  |
| 業務タスク一覧 | `/business/{bizId}/tasks` | Supabase | 実装済 | 一覧/検索/削除 |
| 業務タスク 手動追加 | `/business/manual-add?id={bizId}` | Supabase | 実装済 | タスク＋業務要件の一括登録 |
| 業務タスク 詳細 | `/business/{bizId}/tasks/{taskId}` | Supabase | 実装済 | 業務要件/関連システム要件の参照 |
| 業務タスク 編集 | `/business/{bizId}/tasks/{taskId}/edit` | Supabase | 実装済 | タスク基本情報＋要件（同期保存） |
| 受入条件（要件に保持） | 上記の要件編集 | Supabase | 実装済 | 業務要件/システム要件に構造化配列で保持（Phase 1: jsonb配列へ段階移行） |
| AI修正指示（差分候補） | `/business/{bizId}/tasks/ai-order` | 静的 | 部分実装 | LLM連携なしのデモ |
| 概念辞書一覧 | `/ideas` | Supabase | 実装済 | 一覧/検索/削除 |
| 概念 追加 | `/ideas/add` | Supabase | 実装済 | 自動採番して作成 |
| 概念 詳細/編集 | `/ideas/{conceptId}` / `/ideas/{conceptId}/edit` | Supabase | 実装済 |  |
| 概念の統合/分割 | `/ideas/{conceptId}` | - | 未実装 | ボタン導線のみ |
| システム領域一覧 | `/system-domains` | Supabase | 実装済 | 一覧/検索 |
| システム領域マスタ | `/settings/system-domains` | Supabase | 実装済 | 作成/編集/削除 |
| システム機能一覧（領域内） | `/system-domains/{systemDomainId}` | Supabase | 実装済 | 検索/フィルタ/削除 |
| システム機能 追加 | `/system-domains/{systemDomainId}/functions/create` | Supabase | 実装済 | システム要件作成＋業務要件とのリンク付け |
| システム機能 詳細/編集 | `/system-domains/{systemDomainId}/{srfId}` / `/system-domains/{systemDomainId}/{srfId}/edit` | Supabase | 実装済 | 設計項目/コード参照/ステータス管理 |

- システム要件のCRUD（追加/編集/削除）は、システム機能の詳細/編集画面（`/system-domains/{systemDomainId}/{srfId}/edit`）で行う

#### 4.2.3 照会・可視化・出力・設定（横断）

| 機能 | ルート | データ | 実装状況 | 備考 |
|------|--------|--------|----------|------|
| ダッシュボード | `/dashboard` | 静的 | 部分実装 | サンプル表示。集計/導線は将来 |
| 照会（自然言語検索） | `/query` | 静的 | 部分実装 | サンプル表示。検索/根拠生成は将来 |
| ベースライン履歴 | `/baseline` | 静的 | 部分実装 | 一覧のみ。版詳細/差分は未 |
| グラフビュー | - | - | 未実装 | 画面・データともに未 |
| エクスポート（画面） | `/export` | - | 部分実装 | UIのみ。5章形式の出力は未 |
| プロジェクト設定 | `/settings` | - | 部分実装 | UIはあるが永続化は未（将来） |
| LLM設定 | `/settings/llm` | - | 部分実装 | UIはあるが接続/保存は未 |
| 通知設定 | `/settings/notification` | - | 部分実装 | UIはあるが通知配信は未 |
| 受入条件lint | - | - | 未実装 | 文言lint/検証可能性チェックは未 |
| suspect link管理 | - | - | 未実装 | 判定・重大度付与・一括消化は未 |

---

## 5. エクスポート仕様（Claude Code連携）

本章は、本ツールの正本をClaude Codeが参照できる形式で出力する仕様を定義する。

### 5.1 出力ファイル構成

2.7のデータ構造（業務側とシステム側の分離）に従い、以下の構成で出力する。
```
docs/requirements/
  INDEX.md                           - ルーティング表（全体の目次）
  concept-dictionary.yml             - 概念辞書
  
  business/                          # 業務側の正本
    {業務分類ID}/
      _index.md                      # 業務分類の概要
      {業務タスクID}.md              # 業務タスク＋業務要件＋業務受入条件
  
  system/                            # システム側の正本
    {システム領域ID}/
      _index.md                      # システム領域の概要
      {システム機能ID}.md            # システム機能＋システム要件＋エントリポイント
  
  graph/
    requirements-links.json          # 業務要件↔システム要件のリンク（根拠データ含む）
  
  VERSION.md                         - エクスポート時点の版情報
```

#### ディレクトリ構成の意図

| ディレクトリ | 内容 | Claude Codeの利用シーン |
|-------------|------|------------------------|
| `business/` | 業務タスク・業務要件・業務受入条件 | 「なぜこの変更が必要か」の業務文脈を理解する |
| `system/` | システム機能・システム要件・エントリポイント | 「どのファイルを修正すべきか」を特定する |
| `graph/` | 要件間のリンクと根拠 | 影響範囲の波及を辿る |

### 5.2 業務タスクファイルフォーマット

`business/{業務分類ID}/{業務タスクID}.md`
※受入条件はMVPでは description のみを箇条書きで出力する（status/verification_method/根拠等のメタデータは将来拡張）。
```yaml
---
id: BT-BIL-001
title: 請求書発行
business_domain_id: BD-BIL
business_domain_name: 請求
---

## 概要

請求書を発行し、顧客へ送付するまでの業務フロー。

## 業務要件

### BR-BIL-001: 請求書をPDFで出力できる

#### 受入条件
- 経理担当者が請求書PDFをダウンロードできること
- 請求書PDFに登録番号が印字されていること

#### 関連システム要件
- [SR-BIL-001](../../system/SD-BIL/SF-BIL-010.md#sr-bil-001)
- [SR-BIL-002](../../system/SD-BIL/SF-BIL-010.md#sr-bil-002)

#### 関連概念
- TAX_INVOICE_JP
```

### 5.3 システム機能ファイルフォーマット

`system/{システム領域ID}/{システム機能ID}.md`
```yaml
---
id: SF-BIL-010
title: 請求書出力バッチ
system_domain_id: SD-BIL
system_domain_name: SD請求
entry_points:
  - path: /app/billing/invoice/InvoicePdfGenerator.ts
    type: job
    responsibility: 請求書PDF生成
  - path: /app/billing/invoice/
    type: template
    responsibility: 帳票テンプレート群
---

## 概要

請求書PDFを生成するバッチ処理。月次締め後に実行される。

## システム要件

### SR-BIL-001: 請求書PDFに登録番号と税率別合計を出力

#### 受入条件
- 登録番号が帳票右上に印字されていること
- 税率ごとの合計金額が明細の下に表示されること

#### 関連業務要件
- [BR-BIL-001](../../business/BD-BIL/BT-BIL-001.md#br-bil-001)

#### 関連概念
- TAX_INVOICE_JP

### SR-BIL-002: 請求書PDFを指定フォルダに保存

#### 受入条件
- 出力先フォルダが設定画面で指定できること
- 保存完了後にログが出力されること

#### 関連業務要件
- [BR-BIL-001](../../business/BD-BIL/BT-BIL-001.md#br-bil-001)
```

### 5.4 概念辞書フォーマット

`concept-dictionary.yml`
```yaml
TAX_INVOICE_JP:
  name: 適格請求書
  synonyms: [インボイス, 登録番号, 税率ごとの対価]
  impacts:
    system_domains: [SD-BIL, SD-FI]
    system_functions: [SF-BIL-010, SF-FI-020]
  must_read:
    - system/SD-BIL/SF-BIL-010.md
    - system/SD-FI/SF-FI-020.md
```

### 5.5 リンク・根拠データフォーマット

`graph/requirements-links.json`

業務要件とシステム要件のリンク、およびリンクの根拠を構造化して出力する。
```json
{
  "links": [
    {
      "source": "BR-BIL-001",
      "source_type": "business_requirement",
      "target": "SR-BIL-001",
      "target_type": "system_requirement",
      "evidence": {
        "matched_concepts": ["TAX_INVOICE_JP"],
        "reason": "請求書PDF出力の業務要件を実現するためのシステム要件"
      },
      "last_confirmed": "2025-01-17T12:00:00Z",
      "suspect": false,
      "suspect_severity": null
    },
    {
      "source": "SR-BIL-001",
      "source_type": "system_requirement",
      "target": "SR-FI-003",
      "target_type": "system_requirement",
      "evidence": {
        "matched_concepts": ["TAX_INVOICE_JP"],
        "source_field": "summary",
        "source_span": "消費税調整仕訳",
        "reason": "SD請求でインボイス対応するとFI税務仕訳にも影響"
      },
      "last_confirmed": "2025-01-17T12:00:00Z",
      "suspect": false,
      "suspect_severity": null
    }
  ]
}
```

### 5.6 INDEX.md（ルーティング表）

Claude Codeが最初に読むべきファイル。全体構成と参照方法を示す。
```markdown
# 要件正本 INDEX

## 構成

- `business/` - 業務タスク・業務要件（なぜこの機能が必要か）
- `system/` - システム機能・システム要件・エントリポイント（どう実装されているか）
- `graph/requirements-links.json` - 要件間のリンクと根拠
- `concept-dictionary.yml` - 用語辞書（同義語・影響範囲）

## 参照手順

1. 変更要求の内容から、関連する概念を`concept-dictionary.yml`で検索
2. 概念の`must_read`に記載されたシステム機能ファイルを読む
3. システム機能ファイルの`entry_points`から実装の起点を特定
4. 必要に応じて`graph/requirements-links.json`で波及影響を確認

## 業務分類一覧

| ID | 名称 | ファイル |
|----|------|---------|
| BD-BIL | 請求 | [business/BD-BIL/_index.md](business/BD-BIL/_index.md) |
| BD-FI | 会計 | [business/BD-FI/_index.md](business/BD-FI/_index.md) |

## システム領域一覧

| ID | 名称 | ファイル |
|----|------|---------|
| SD-BIL | SD請求 | [system/SD-BIL/_index.md](system/SD-BIL/_index.md) |
| SD-FI | FI会計 | [system/SD-FI/_index.md](system/SD-FI/_index.md) |
```

### 5.7 Claude Code Skill連携

Claude Codeの`.claude/skills/`にSKILL.mdを配置し、「まずINDEX.mdを読み、概念辞書でヒットしたmust_readを読む」手順を提案する。

SKILL.mdはprogressive disclosureに従い軽量に保ち（目安500行以下）、詳細手順は別ファイルに分離する。
```markdown
# 要件正本参照スキル

## 概要
このプロジェクトには構造化された要件正本があります。変更を行う前に必ず参照してください。

## 参照手順
1. `docs/requirements/INDEX.md` を読む
2. 変更内容に関連する概念を `concept-dictionary.yml` で検索
3. 概念の `must_read` に記載されたファイルを読む
4. システム機能ファイルの `entry_points` から実装起点を確認
5. 受入条件を確認し、何を満たせばOKか理解する

## 注意
- 影響範囲が不明な場合は `graph/requirements-links.json` で波及を確認
- 受入条件を満たさない変更は行わない
```

## 6. 技術アーキテクチャ（影響分析AI）

### 6.1 全体構成
```
┌─────────────────────────────────────────────────────────────┐
│                    影響分析AI                                │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│   ┌──────────────┐  ┌──────────────┐  ┌──────────────────┐ │
│   │   正本DB     │  │     RAG      │  │ Claude Code SDK  │ │
│   │  (Supabase   │  │  (pgvector)  │  │ (コード依存分析) │ │
│   │  + pgvector) │  │              │  │                  │ │
│   └──────┬───────┘  └──────┬───────┘  └────────┬─────────┘ │
│          │                 │                   │           │
│          └─────────────────┼───────────────────┘           │
│                            ▼                               │
│              ┌─────────────────────────┐                   │
│              │   エージェント          │                   │
│              │   オーケストレーター    │                   │
│              │   (LangGraph)           │                   │
│              └────────────┬────────────┘                   │
│                           │                                │
│                           ▼                                │
│              ┌─────────────────────────┐                   │
│              │   リーズニングモデル    │                   │
│              │   (GPT-5クラス)         │                   │
│              └─────────────────────────┘                   │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### 6.2 コンポーネントの役割

| コンポーネント | 役割 | 技術選定 |
|---------------|------|---------|
| 正本DB | 業務要件・システム要件・エントリポイントの保持、リレーション管理 | Supabase (PostgreSQL) |
| RAG | 正本の意味検索（類似要件の発見、概念辞書のマッチング） | pgvector |
| Claude Code SDK | コード依存分析（エントリポイントからの依存展開、逆引き） | Claude Code SDK (Python) |
| オーケストレーター | マルチステップの影響分析フロー制御 | LangGraph |
| リーズニングモデル | 根拠の生成、提案文の作成、曖昧な入力の解釈 | Claude / GPT-5クラス |

### 6.3 コード依存分析の委譲

コード依存グラフは自前で構築・維持せず、Claude Code SDKに委譲する。

| 観点 | 自前で依存グラフ構築 | Claude Code SDKに委譲 |
|------|---------------------|----------------------|
| 実装コスト | 高い（言語別パーサー） | 低い（指示を投げるだけ） |
| 維持コスト | 高い（グラフの陳腐化） | なし（毎回リアルタイム解析） |
| 精度 | 静的解析の限界 | LSP + コード理解でより正確 |
| 速度 | 高速（事前計算済） | 遅い（毎回解析） |

速度問題の対処：
- キャッシュ：同じエントリポイントの依存は一定期間キャッシュ
- バックグラウンド更新：変更要求の起票時点で依存探索を開始
- 深さ制限：最初は2階層まで、必要なら追加探索

### 6.4 影響分析のフロー
```python
# LangGraphでの実装イメージ

class ImpactAnalysisState(TypedDict):
    change_request: str
    business_requirements: list      # 正本から取得
    system_requirements: list        # 正本から取得
    entry_points: list               # 正本から取得
    code_dependencies: dict          # Claude Code SDKから取得
    reverse_lookup_results: list     # コード→正本の逆引き結果
    impact_proposal: dict            # 最終提案

async def fetch_from_正本(state):
    """トップダウン：正本DBから関連要件・エントリポイントを取得"""
    # Supabase + pgvectorで検索
    ...

async def analyze_code_dependencies(state):
    """コード解析：エントリポイントから依存を展開"""
    client = ClaudeSDKClient()
    for entry_point in state["entry_points"]:
        result = await client.send_message(
            f"{entry_point}を起点に、参照しているファイルを2階層まで列挙"
        )
        state["code_dependencies"][entry_point] = result
    return state

async def reverse_lookup_正本(state):
    """ボトムアップ：依存ファイルから正本へ逆引き"""
    for file_path in state["code_dependencies"].values():
        # エントリポイントと突合
        # 紐づくシステム機能・システム要件・業務要件を取得
        ...

async def generate_proposal(state):
    """提案生成：影響範囲と根拠を人間に提示"""
    ...
```

### 6.5 デプロイ構成

| コンポーネント | デプロイ先 | 備考 |
|---------------|-----------|------|
| Next.jsフロントエンド | Vercel | UI |
| LangGraphオーケストレーター | Cloud Run / EC2 | Python、Claude Code CLIインストール済み |
| Supabase | Supabase Cloud | 正本DB + pgvector |
| 対象リポジトリ | GitHub | オーケストレーターからclone/mount |

LangGraphが動くサーバー（コンテナ）にClaude Code CLIもインストールし、SDKから呼ぶ。リポジトリは事前にclone or volume mountしておく。

### 6.6 コスト・クォータの考慮

Claude Code SDKはClaude Codeのクォータを消費する。

| 操作 | 想定トークン消費 | 頻度 |
|------|-----------------|------|
| 依存探索（1エントリポイント） | 5,000〜20,000 | 変更要求あたり5〜20回 |
| 逆引き提案生成 | 2,000〜5,000 | 変更要求あたり1〜3回 |

変更要求1件あたりの影響分析コストを計測し、運用コストの見通しを立てる。
